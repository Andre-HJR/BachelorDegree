\chapter{绪论}
\label{chap:references}

\section{引言}

操作系统的“Page Fault”异常处理例程首先会判断，该数据的虚拟地址是否是该任务的合法地址？根据之前操作系统的设置，答案是“Yes”；抛出异常之后， 内核取出保存在相应页表项中地址，通过地址转换将获取虚拟地址的物理地址；后把对应的物理页号写入页表项，把页表项中的存在位设“1”；最后，返回该任务，让该任务重新执行访问数据的指令。此时， 处理器再次执行这条指令，块表还是没有相应的页表项信息，而对应页表项内容合法，所以块表会发生缓存操作，并完成地址转换，实现访问数据指令的执行。

相对于内存访问，交换区的扇区访问要慢很多。为了进一步提高系统的执行效率，当操作系统在让存储设备进行I/O访问时，可将当前任务设置为阻塞状态，并切换其他可以运行的任务继续执行。通过这种任务调度方式，可以充分发挥多道程序和分时多任务的整体执行效率

这是2022年暑假参加rCore\pagescite{rcore0}社区第二阶段的课题， 本文地工作是课题（异步操作系统）延续。课题主要探索利用Rust先天对异步支持的优势来重新设计rCore并尝试为其添加异步的特性。

% TODO: 存在一些问题
操作系统设计的意义：

\begin{enumerate}
\item 库操作系统是根据某类应用的特殊需求，由某一高级编程语言将原本属于操作系统内核的某些资源管理功能，如文件磁盘 I/O、网络通信等，按照模块化的要求，以库的形式提供给应用程序的特殊操作系统。\pagescite{rcore0}它能代替操作系统内核合理地管理和控制所涉及的计算机资源，并将所涉及的计算机。\pagescite{rcore0}
\item 资源直接暴露给应用程序， 让应用程序直接访问底层（虚拟）硬件， 以便应用程序能够高效地运行。特别地，它与应用程序在编译时被链接到一起，形成一个只有单地址空间的二进制文件并工作在应用层，是构建 Unikernel 的一个必不可少的系统组件。\pagescite{rcore0}
    \begin{itemize}
        \item Linux 作为主流的开源操作系统发展已经走过三十多个年头了，历史的包袱已经略显沉重， 随着物联网的快速袭来， 单片机的开发也日益增多。 Linux Kernel内核中的许多module可能略显多余甚至很多存在功能冗余， 这样不急增加单片机的设计难度还为增加单片机的内存压力。可供定制和模块化良好的库操作系统可以缓解单片机开发中系统的选择匮乏。
    \end{itemize}
\item 计算机多线程的异步处理。相较同步而言， 异步的处理过程不会发生阻塞，而是继续后续的工作，直至其它线程处理完成，后回调，唤醒线程。
    \begin{itemize}
    \item 异步的需求主要来自任务的并发，而且是发生大量的任务请求。如果同步进行系统响应，那将是一件十分可怕的事情，系统以阻塞的方式对请求进行响应，那可能是一段很长的等待， 尤其可怕的是， CPU存在极大可能是一个空闲的状态。 例如， 存在一个I/O事件， 在请求I/O的控制权之后，CPU将无需为此事件提供服务，那么CPU就会空闲下来，从CPU资源使用的角度看这是十分不可取的，CPU的资源十分宝贵，一定需要让CPU尽可能处于忙的工作环境下。异步，异步的另一种含义则来自于多线程的异步处理。异步处理不阻塞当前线程，而是继续后续工作，直至其它线程处理完成， 并通过全局的唤醒机制回调通知此线程。 从而使得核心资源处于一个忙碌的状态。
    \end{itemize}
\end{enumerate}

毕设工作尝试围绕异步进行操作系统的调度设计，期望为操作系统内核异步设计积累经验和提供有所裨益的思路。

\section{研究背景与意义}

研究目的：异步的提出是为了提高程序在热点事件下的并发性能。

研究意义： 编译器与操作系统进行密切配合，用户态的异步系统调用会同编译器自动生成相应的系统调用请求代码和协程控制块数据结构；只有在第一次系统调用和最后一次系统调用时需要进入内核空间；中间各次的系统调用只进行系统调用结果查询和进程、线程或协程切换。

研究好处： 异步调度下，操作系统应对高并发的任务时，可以获得更好的响应表现，CPU可以一直处在忙碌的状态。无栈的协程，内部的状态转换通过状态机图实现，无需函数主动调用yield，内部也只是状态的转换，无需多余的栈空间开销。

\section{国内外研究现状}

\subsection{国外现状}
国外异步操作系统的研究以Linux为主，其中以libaio和io\_uring的研究比价典型。以下是这两种情况的简要阐述。

\subsubsection{Libaio}

\begin{figure}[htb]
    \figureCapSet
    \centering
    \includegraphics[width=.8\linewidth]{figure/c1/libaio.png}
    \caption{Libaio\pagescite{IoUring1}的工作流}
    \label{figure:c1libaio}
\end{figure}

Libaio的工作流如\autoref{figure:c1libaio}所示， 以read的请求来说， direct IO\pagescite{IoUring1}的模式会把从磁盘上读取的数据直接返回给了用户态的内存空间，不会在内核中缓存，当存在多次重复读取的场景，每次都需要读取磁盘，这样会增加磁盘的压力。


\subsubsection{IO\_URING}

\begin{figure}[htb]
    \figureCapSet
    \centering
    \includegraphics[width=.8\linewidth]{figure/c1/iouring.png}
    \caption{io\_uring\pagescite{IoUring2}的工作流}
    \label{figure:c1iouring}
\end{figure}

io\_uring的工作流如\autoref{figure:c1iouring}所示，io\_uring的基本逻辑与linux-aio\pagescite{IoUring2}是类似的，提供两个接口，一个将I/O请求提交到内核，一个从内核接收完整的事件。但是在设计上是真正的异步。通过参数，通过系统调用，将请求放入请求队列，不会做额外的工作，保证了应用不会被阻塞。io\_uring无需像aio那样使用 poll+read/write来处理sockets，只需要提交一个阻塞式的度，请求完成之后，就会出现在CQ（completion ring）。io\_uring实例在设计上有两个环形队列，请求队列和完成队列，使其能在内核空间和用户空间之间共享， 两者都是单生产者、单消费者，提供无锁的接口，内部使用内存屏障同步。

\textbf{io\_uring可以工作在三种模式上}

\begin{enumerate}
\item 中断驱动的默认模式。提交相应的I/O请求，查询完成队列的状态判断是否完成。
\item 轮询模式，通过文件系统和块设备支持轮询作为基础，相比前一种模式，虽然延迟比较低，但会消耗更多计算资源。当一个读或写请求提交给轮询上下文之后，应用必须轮询CQ队列，判断请求是否已经完成。
\item 内核轮询模式，会创建一个内核线程来执行请求队列的轮询工作。\pagescite{IoUring1}
\end{enumerate}

io\_uring的内核轮询模式， 使得用户空间的应用无需切到到内核态就可以触发I/O的操作。\pagescite{IoUring0}通过请求队列来提交请求事件，以及监控完成队列的状态，无需系统调用，就能提交和捕获I/O操作。\pagescite{IoUring0}


\subsection{国内现状}

\subsubsection{tornado-os的调度器}

\begin{figure}[htb]
    \figureCapSet
    \centering
    \includegraphics[width=.8\linewidth]{figure/c1/sharedscheduler.png}
    \caption{shared\_scheduler\pagescite{tornado0}的工作流}
    \label{figure:c1sharedscheduler}
\end{figure}

调度器被同时暴露在内核空间和用户空间， 这将所使用的代码、任务资源都在内核和用户之间共享。用户和内核拥有近乎相同的异步调度逻辑。即从共享的任务池中接收任务并执行。

总结一下，基本上，异步系统调用的执行过程应当符合，如下设计，


\begin{enumerate}
    \item 第一次异步系统调用时
    \begin{itemize}
        \item 用户进程准备系统调用参数、发出系统调用请求；
        \item 内核进程将映射共享内存、发起相应服务协程的异步执行；
        \item 内核进程执行完服务协程后，再响应队列保存返回值，并通过用户态中断通知应用进程；
    \end{itemize}

    \item 第二次异步系统调用时
    \begin {itemize}
        \item 用户进程再请求队列转杯系统调用参数；在共享内存的响应队列中查看一次系统调用的结果；
        \item 内核进程在完成第一个服务协程后，在共享内存的响应队列中保存返回值，主动查询新的系统调用请求，并执行；如果没有新的请求，则让出CPU；
    \end{itemize}
\end{enumerate}

发展：异步的调度的研究应该会是未来网络系统服务的一个方向，随着网络的普及和发展，异步是一种可行的高并发设计思路，是有其研究的价值和意义。




\section{研究的目标与内容}

\subsection{目标}

程序有执行独立的正交化的任务，彼此之间无需串行执行。例如，现代的网络服务器可以同时监听并响应大量的客户端请求。宏观而言，对于每个请求，服务器的响应无需按照某个特定的处理顺序，理论上每个请求可以被当作独立的执行单元，并行执行。当操作系统的底层服务并发提供支持，则网络服务程序会有更好的性能表现。

操作系统中，相对于内存访问，交换区的扇区访问要慢很多。为了进一步提高系统的执行效率，当操作系统在让存储设备进行I/O访问时，可将当前任务设置为阻塞状态，并切换其他可以运行的任务继续执行。通过这种任务调度方式，可以充分发挥多道程序和分时多任务的整体执行效率。

本次毕设工作是尝试利用Rust\pagescite{rust0}语言所提供的并发模型和模块管理，在内核空间中实现并发安全、模块化。而其的异步机制，则为操作系统并发提供了优化参考。模块化系统内核，为内核灵活开发提供帮助。
\subsection{内容}

操作系统内核，为了提升线程的性能，基于编程架构，系统尝试在应用层复用线程资源，由此引出协程。毕设工作尝试使得操作系统中不同资源被调度器所共享，调度器使得资源同时共享给内核和用户，两者将拥有近乎相同的调度处理机制，同时，为了降低系统的耦合程度，尝试模块化系统内核，尝试将系统组件剥离。所以，本文尝试以下工作：

Ring\_scheduler: 自己的工作是继续tronado-os\pagescite{tornado0}的工作， 实现一个类似shared\_ scheduler\pagescite{tornado0}的ring\_scheduler，将其接入rCore\pagescite{rcore0}并使得其可以工作在rCore中，并试着将其从内核模块中正交出来，形成一个独立的模块（Crate）。 而异步的设计往往需要底层硬件的支持， 因此需要完成对底层硬件的异步工作，而磁盘的读写被抽象为文件的读写，当硬件的异步完成时，需要对文件系统进行合理的改造使其能完成异步相应的工作需求。ring\_scheduler的接入需要在内核中实例化，提供相应的系统调用。

模块化的设计：预先的设想只是将模块在语言静态编译时就完成所有模块的载入工作，但是得益于Theseus\pagescite{theseus0}的启发，有考虑在所有模块正交完成之后，尝试动态的内核模块的载入，其核心是对每个模块的elf的解析，从而在内核运行时动态载入。上述两者的模块化思路，前者主要依赖于语言的编译时，其实质只是将杂糅在一起的模块通过正交，变成独立且具有层次的的依赖树，模块之间的依赖通过各自之间ABI的调用形成约束；后者主要依赖语言的运行时，是对模块的进一步抽象，因为依赖于语言的运行时，所以需要独立的可以管理模块的内核单元对模块进行树状管理。


\section{论文的组织安排}

本文的组织结构如下：

\begin{itemize}
\item[第一章] 介绍了操作系统异步调度设计的研究背景，意义，相关的国内外研究现状，由此确定了研究的目标与内容。
\item[第二章] 介绍开发系统软件时，所需要具备的一些理论和技术支持，对Rust\pagescite{rust0}语言、riscv\pagescite{riscv0}和异步设计做了阐述。
\item[第三章] 详细描述了系统的设计， 从内核设计、异步调度、模块设计三个方面设计系统。
\item[第四章] 对系统的部分实现进行解释，遵循系统设计的三个方面，依次对部分代码进行阐述。
\item[第五章] 总结了本文工作的大致内容，自己在开发过程中的一些难点和相关的一些经验，同时提出了对本文系统设计改进的些许展望。
\end{itemize}
