\subsection{内存管理}

应用程序中，动态内存分配，依赖系统所管理的堆。其设计上应当有如下功能：

\begin{itemize}
\item 初始时能提供内存空间作为初始的堆内存。在没有分页机制情况下，堆是物理内存，否则就是虚拟的。\pagescite{rcore0}
\item 提供分配和释放内存的函数接口。调用方通过分配接口得到内存块，也能通过释放接口回收空间。\pagescite{rcore0}
\item 提供空间管理的分配算法。动态地维护空闲和已分配的内存。\pagescite{rcore0}
\item （可选）提供建立在堆上的数据结构和操作。有了分配与释放接口，就可以实现动态数组，动态字典等空间灵活可变的数据结构。\pagescite{rcore0}
\end{itemize}

\subsubsection{GlobalAlloc}
Rust的GlobalAlloc需要在no\_std的环境中提供一个全局的动态内存管理，Rust\pagescite{rust0}将利用分配器来管理空间，使得与堆相关的智能指针或容器数据结构可以正常工作。具体而言，内存管理接口需要如下约束：

\begin{lstlisting}[caption=GlobalAlloc的Trait约束]
pub unsafe fn alloc(&self, layout: Layout) -> *mut u8;
pub unsafe fn dealloc(&self, layout: Layout);
\end{lstlisting}

当完成Heap的接入的时候，在no\_std的环境中任然还需要为其提供, 当动态内存分配失败时，系统的处理函数, 简单处理，让\verb|#[alloc_error_handler]|直接返回\verb|panic|的异常。

\subsubsection{地址空间}

地址空间，从某种程度上讲，可以将它看成一块巨大但并不一定真实存在的内存。在应用程序中，系统分配给应用一个地址范围，且独占的连续空间，因此应用程序可以在划分给它的地址空间中随意规划内存布局，它的各个段也就可以分别放置在地址空间中它希望的位置（当然是操作系统允许应用访问的地址）。应用也可以使用地址作为索引来读写自己空间的数据，就类似于用物理地址作为索引来读写物理内存上的数据。这种地址被称为虚拟地址。


\subsubsection{分页管理}

具体的分页逻辑参考\autoref{figure:c2addressv2p}, 其思路来自Riscv平台下的Sv39的地址转换。

内核以页为单位进行物理内存管理，应用的地址空间会被分成若干个虚拟页面，而物理内存同样可以被分成若干个物理页帧，页面和页帧大小相同，每个虚拟页面中的数据实际上都存储在某个物理页帧上。\pagescite{riscv0}

为了方便实现虚拟页面到物理页帧的地址转换，标记每个虚拟页面和物理页帧一个编号，分别称为 虚拟页号和物理页号。每个应用都有一个表示地址映射关系的 页表 (Page Table) ，里面记录了该应用地址空间中的每个虚拟页面映射到物理内存中的哪个物理页帧，即数据实际被内核放在哪里。\pagescite{rcore0}

如果将页表看成一个键值对，其键的类型为虚拟页号，值的类型则为物理页号。\pagescite{rcore0}当内存控制单元进行地址转换，虚拟地址会分为两部分（虚拟页号，页内偏移），内存控制单元先找到虚拟地址的虚拟的页号，然后查当前应用的页表，根据虚拟页号找到物理页号；\pagescite{rcore0}最后按照虚拟地址的页内偏移，给物理页号对应的物理页帧的起始地址加上一个偏移量，这就得到了实际访问的物理地址。

\subsubsection{内核与应用地址的空间分配}

在分页模式开启之后，CPU先拿到虚存，通过内存管理单元的地址转换变成物理地址，再给CPU去访问物理内存。地址空间抽象的重要意义在于空间隔离 ，当应用执行前，内核需要内存控制单元，这个应用的多级页表进行地址转换。\pagescite{rcore0}而应用地址空间在创建的时候也顺带设置好了多级页表，使得只有那些存放了它的代码和数据的物理页帧能够通过该多级页表被映射到，这样它就只能访问自己的代码和数据而无法触及其他应用或内核的内容。\pagescite{rcore0}

启用分页模式下，内核代码的地址也会被看成一个虚拟地址并经过内存管理单元的地址转换，因此需要为内核构造一个地址空间，它除了允许内核的各数据段能够被正常访问之后，还应包含所有应用的内核栈以及一个跳板 (Trampoline) 。

通常在内核空间中跳板放在最高的一个虚拟页面中,因为分页机制的关系，使得每次发生Trap的时候，Riscv的satp的会发生改变，而trap的异常处理函数只有在内核空间中才能被访问，因此如此设计可以设计在地址空间切换时指令能够被正确执行。接下来则是从高到低放置每个应用的内核栈。

应用空间，效仿内核地址空间的设计，同样借助页表机制使得应用地址空间的各个逻辑段也可以有不同的访问方式限制，这样可以提早检测出应用的错误并及时将其终止以最小化它对系统带来的恶劣影响。

\subsubsection{Yield系统调用}

需要知道当前所处的地址空间，用户的上下文，还要相应的地址映射关系。由于内核空间和用户空间之间的转换是通过跳板页实现的，因此用户的上下文，将会被存放在跳板也的数据段中，而在分页机制的情况下，相应上下文的地址可以通过相应的公式计算出来（用户可以获取一页的空间保存上下文）。

参考tornado-os的设计，利用tp寄存器，由其指向一个存有KernelHartInfo的地址。而用户的地址空间映射就被包存在这里。

\begin{lstlisting}[caption=KernelHartInfo的结构]
#[repr(C)]
pub struct KernelHartInfo {
    hart_id: usize,
    // ...
    asid_alloc: (LinkedList<usize>, usize),   // (空余的编号回收池，目前已分配最大的编号)
    user_mm_sets: (LinkedList<MemorySet>, usize), // (注册的用户地址空间映射，上一次进入的用户地址空间编号)
}
\end{lstlisting}

KernelHartInfo游走在内核态和用户态之间。记录了如CPU的核心编号， 用户空间的地址映射信息，地址分配的信息等等。

\subsection{进程通信}
% TODO: Need Fix
为了在用户态可以借助系统服务灵活管理、控制应用执行，可以在已有的任务抽象基础做一些拓展，形成新的抽象：进程 ，并实现若干基于其的系统调用。\pagescite{rcore0}

\begin{itemize}
\item 创建：父进程创建子进程。用户在终端键入命令或用鼠标点击应用程序，调用系统服务来创建进程，运行程序。\pagescite{rcore0}
\item 销毁：进程销毁。进程在运行完成后可自行退出，但还需要其他进程来回收相应资源。\pagescite{rcore0}
\item 等待：父进程等待子进程退出。\pagescite{rcore0}
\item 信息：获取进程的状态信息。\pagescite{rcore0}
\item 其他：其他的进程控制服务。\pagescite{rcore0}
\end{itemize}

参照rcore\pagescite{rcore0}的设计， 进程模型有三个运行状态：就绪态、运行态和等待态；有基于独立页表的地址空间；可被操作系统调度来分时占用 CPU 执行；可以动态创建和退出；可通过系统调用获得操作系统的服务。与之对应的一些重要的结构。

\begin{itemize}
\item 进程标识符和内核栈：组成进程控制块的重要部分。
\item 任务控制块：进程的主要数据结构。
\item 任务管理器：管理进程的主要数据结构。
\item 处理器管理结构：进程调度，维护进程的处理器状态。
\end{itemize}

从而与之对应的重要的功能

\begin{itemize}
\item 初始进程：创建第一个用户态进程；
\item 进程调度：当进程主动调用yield\pagescite{rcore0}交出CPU使用权或者内核把本轮分配的时间片用尽的进程换出且换入下一个进程；
\item 进程生成：两个重要系统调用fork/exec的实现；
\item 进程资源回收：当进程调用exit\pagescite{rcore0}正常退出或者出错被内核终止之后如何保存其退出码，其父进程通过waitpid系统调用收集该进程的信息并回收其资源。
\item 字符输入：通过shell获得字符输入；\pagescite{rcore0}
\end{itemize}

内核初始化完毕之后会调用task模块中的启用进程初始化函数将初始进程加入任务管理器。\pagescite{rcore0}通过task模块提供的任务切换原语暂停当前任务并切换到下一个任务，此时会调用yield主动交出使用权，当本轮时间片用尽或者由于某些原因内核中的处理无法继续的时候，就会在内核中调用此函数触发调度机制并进行任务切换。

在内核中手动生成的进程只有初始进程，余下的进程都是直接或间接由初始进程fork出来。\pagescite{rcore0}当一个子进程被fork之后，其可以调用exec来加载并执行另一个可执行文件。\pagescite{rcore0}因此，fork/exec\pagescite{rcore0}两个系统调用提供了进程的生成机制。

在子进程内核栈上压入一个初始化的任务上下文，使得内核一旦通过任务切换到该进程，就会跳转进入用户态。\pagescite{rcore0}在复制地址空间的时候，子进程的地址空间上下文也是完全从父进程复制过来的，由此可以保证子进程父进程回到用户态的那一瞬间CPU的状态是完全相同的。\pagescite{rcore0}由于地址空间是复制的，所以两个进程的应用数据也是完全相同的。

waitpid\pagescite{rcore0}是一个立即返回的系统调用，它的返回值语义是：如果当前的进程不存在一个进程则返回-1；如果存在一个进程编号为pid的僵尸子进程，则正常回收并返回子进程的pid，并更新系统调用的退出码参数为 exit\_code 。这里还有一个 -2 的返回值，它的含义是子进程还没退出，通知用户库，当用户库看到是-2后，就进一步调用yield系统调用，让当前父进程进入等待状态。

基于基本的进程模型，本文尝试实现操作系统中管道和信号机制。为进程通行提供相应的系统原语。两者的定义如下文所述。

% TODO: Need Fix
\subsubsection{管道}


管道是一种进程间通信机制，由操作系统提供，并可通过直接编程或在shell程序的帮助下轻松地把不同进程（目前是父子进程之间或子子进程之间）的输入和输出对接起来。也可以将管道看成一个有缓冲区大小的队列，分为读、写两端，通过不同的文件描述符来访问。\pagescite{rcore0}

读端用来从管道中读取，而写端用来将数据写入。\pagescite{rcore0}管道是一个队列，读取数据则从队头弹，写入数据则把数据写入队尾。\pagescite{rcore0}由于管道的缓冲区大小是有限的，一旦缓冲区被填满就无法继续写入，需要等到队列弹出数据后才能继续写入。当缓冲区为空的时候，读端自然也不能继续从里面读取数据，需要等到写端写入了一些数据之后才能继续读取。

\subsubsection{信号}

信号是操作系统中实现进程间通信的一种机制，用来通知进程一个特定事件已经发生，需要处理。\pagescite{rcore0}当一个信号发送给一个进程时，操作系统会中断接收到信号的进程的正常执行流程并对信号进行处理。\pagescite{rcore0}如果该进程定义了信号的处理函数，那么这个处理函数会被调用，否则就执行默认的处理行为，比如让该进程退出。\pagescite{rcore0}在处理完信号之后，如果进程还没有退出，则会恢复并继续进程的正常执行。

\subsection{文件系统}

文件系统,在类Unix系统设计中，文件这个概念的提出是具有划时代意义的。文件是对设备的高度抽象，尤其是对存储结构的抽象，使得这个读写是文件的读写相互绑定简化了磁盘控制提高了系统读写数据的能力。文件系统参考遵循rcore的easy-fs设计，进行实现。

\subsubsection{文件}

从用户的角度看，常规文件是在持久存储设备上的字节序列，每个常规文件都有一个文件名 ，通过其来区分不同的文件。\pagescite{rcore0}方便起见，在下面的描述中，“文件”有可能指的是常规文件、目录，也可能是之前提到的若干种进程可以读写的 标准输出、标准输入、管道等I/O 资源，请同学自行根据上下文判断取哪种含义。

\subsubsection{目录}

早期的文件系统通过文件名来区分文件，但是这会造成一些归档和管理上的困难。如今的使用习惯是将文件根据功能、属性的不同分类归档到不同层级的目录之下。这样就很容易逐级找到想要的文件。结合用户和用户组的概念，目录的存在也使得文件访问权限控制更加容易，只需要对于目录进行设置就可以间接获得用户集合对目录下文件的访问，使得系统能够更加安全的支持多用户对不同文件的操作需求。

\subsubsection{文件的读写和权限结构}

\begin{lstlisting}[caption=文件系统基本读写]
pub trait File: Send + Sync {
    fn readable(&self) -> bool;
    fn writable(&self) -> bool;
    fn read(&self, buf: UserBuffer) -> usize;
    fn write(&self, buf: UserBuffer) -> usize;
}
\end{lstlisting}

\begin{itemize}
\item r 表示是否允许获取目录下的文件和目录；\pagescite{rcore0}
\item w 表示是否允许在目录下创建和删除文件或子目录；\pagescite{rcore0}
\item x 表示是否允许进入目录。\pagescite{rcore0}
\end{itemize}


\subsubsection{Easy-fs\pagescite{rcore0}的磁盘布局}

\begin{figure}[htb]
    \figureCapSet
    \centering
    \includegraphics[width=.8\linewidth]{figure/c3/easyfsdevicemap.png}
    \caption{Easy Fs 的磁盘布局}
    \label{figure:c3easyfsdevicemap}
\end{figure}


顶层的块，其是文件系统的超级块，以魔数的形式提供文件系统合法性检查，同时还具有定位其他连续区域的功能。\pagescite{rcore0}

第二个区域是一个索引节点位图，记录了后面区域中节点使用的使用情况。\pagescite{rcore0}

第三个区域是索引节点区域，其中的每个块都存储了若干个索引节点。\pagescite{rcore0}

第四个区域是一个数据块位图，记录了后面的数据块区域的使用情况。\pagescite{rcore0}

最后的区域则是数据块区域，其每个已分配的块保存了文件或目录中的具体数据内容。\pagescite{rcore0}


\subsection{并发处理}

线程是进程的组成部分，进程可包含多个线程，同一个进程的线程共享进程资源。\pagescite{rcore0} 进程是程序的执行单元，是程序对数据集合进行操作的一次过程，是系统进行资源分配和调度的基本。线程提出后，进程则是线程的资源容器，线程是程序的基本执行实体。\pagescite{rcore0}

数据不一致性、不确定的计算结果，意味在操作系统的执行过程中，可能存在并发问题，并导致程序或操作系统执行失败。我们先给出 线程的数据一致性 的定义：在单处理器（即只有一个核的CPU）下，如果某线程更新了一个可被其他线程读到的共享数据，那么后续其他线程都能读到这个最新被更新的数据。

当多个线程共享同一进程的地址空间时，每个线程都可以访问属于这个进程的数据（全局变量）。\pagescite{rcore0}如果每个线程使用到的变量是其他线程无法操作的，则各个线程访问的变量和其结果都是可以预估的，就不存在资源竞争的问题。\pagescite{rcore0}如果变量是只读的，也不会存在一致性问题。

当两个以上的线程尝试竞争访问同一资源时，执行结果将是未定义的，其取决于不可预知的执行顺序，这种情况称为 线程的竞态条件。该问题可能导致应用程序或操作系统执行失败。而线程的数据不一致问题和竞态条件问题的根本原因是调度的不可控性 ：即读写共享变量的代码片段会随时可能被操作系统调度和切换。

常见处理资源竞争的解决方案有互斥锁，条件变量以及信号量。

\subsubsection{互斥锁}

互斥锁是操作系统中用于保护共享资源的机制。互斥锁能够确保在任何时候只有一个线程访问共享资源，从而避免资源竞争导致的数据不一致的问题。在获取互斥锁的时候，线程会被挂起，直到另一个线程释放了锁。

\subsubsection{条件变量}

条件变量是操作系统中的一种同步原语，可用于在多个线程之间进行协作，即允许一个线程在另一个线程完成某些操作之前等待。条件变量与互斥锁经常一起使用，以保证在同一时刻只有一个线程在访问共享资源。

线程通过更改布尔值并通知条件变量来发送信号，而主线程则使用条件变量来等待信号。首先，定义一个元组 (Mutex<bool>, Condvar)，使用 Arc\pagescite{rust0}将其包装在一个共享的指针中。这个指针会产生两个副本，两个线程都可以访问这个元组。\pagescite{rcore0}然后，启动一个新的线程，并在这个线程内部使用互斥锁来更改共享的布尔值。最后，它使用条件变量来等待这个布尔值被更改，最后退出循环。

\subsubsection{信号量}

信号量是操作系统中的一种同步原语，用于在多个线程或进程之间共享资源时进行互斥访问。它通常是一个整数值，用于计数指定数量的资源可用。当一个线程需要使用资源时，它会执行信号量的获取操作，如果信号量的值小于等于零，则线程将压入阻塞队列，（信号量的值变为正数，则会弹出，即唤醒）；否则将信号量的值减少，操作正常返回。另一方面，当一个线程完成使用资源后，它可以执行信号量的释放操作，将信号量的值加一，并唤醒一个或所有挂起的线程。