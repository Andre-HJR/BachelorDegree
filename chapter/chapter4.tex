\chapter{系统实现}
\label{chap:SystemImplement}

\section{内核}

\subsection{内存管理}

\subsubsection{地址空间的映射}

获取用户任务的一些信息， 
\begin{lstlisting}[caption=用户任务信息获取]
pub async fn prepare_user<S: Into<String>>(user: S, kernel_stack_top: usize) {
    // ...
    let mut user_memory = load_user(&user).await;
    let user_asid = user_memory.address_space_id.into_inner();
    let swap_cx_va = VirtualAddress(swap_contex_va(user_asid));
    let swap_cx_vpn = VirtualPageNumber::floor(swap_cx_va);
    let swap_cx_ppn = user_memory.mapping.translate(swap_cx_vpn).unwrap().page_number();
    // ...
}
\end{lstlisting}

代码从上到下，依次异步创建用户态的地址空间的映射，记录用户的上下文的虚地址，记录上下文的虚拟页号，记录上下文的物理页号。

\begin{lstlisting}[caption=向KernelHartInfo注入地址空间信息]
pub fn load_user_mm_set(mm_set: MemorySet) -> bool {
    use_tp_box_move(|b| {
        let (link, _prev) = &mut b.user_mm_sets;
        for set in link.iter() {
            if set.address_space_id == mm_set.address_space_id {
                return false;
            }
        }
        link.push_back(mm_set);
        true
    })
}
\end{lstlisting}
通过load\_user\_mm\_set将用户的地址空间的映射注入到KernelHartInfo，此时KernelHartInfo就携带了地址空间映射的信息，这样在跨越不同空间时其地址映射结构就会得到保存，在恢复上下文时，应用的物理的值就可以被正确找到。


\begin{lstlisting}[caption=将地址空间信息传递给用户]
pub async fn prepare_user<S: Into<String>>(user: S, kernel_stack_top: usize) {
    // ...
    *swap_cx = trap::SwapContext::new_to_user(
        kernel_satp,
        0,
        tp,
        kernel_stack_top,
        user_stack_top,
        user_trap_handler as usize,
    );
    // ...
}
    
\end{lstlisting}

此处，内核通过tp寄存器，将地址空间传递给用户，而在ring\_scheduler则通过gp寄存器将地址空间传递给用户。\verb|swap_cx.set_gp(SHAREDPAYLOAD_BASE)|。


\subsubsection{内核态与用户态之间的转化}

\begin{lstlisting}[caption=由内核态进入用户态]
pub unsafe extern "C" fn supervisor_to_user() -> ! {
    core::arch::asm!(
        "csrw   satp, a1
        sfence.vma",
        "
        ld      t0, 9*8(a0)
        csrw    sscratch, t0
        ",
        "
        // ... 恢复通用寄存器的上下文 ...
        ",
        "csrrw  a0, sscratch, a0",
        "sret",
        options(noreturn)
    )
}
\end{lstlisting}

自\verb|sfence.vma|刷新页表之后，内核从SwapContext中恢复用户的上下文，将用户的a0寄存器保存在sscratch寄存器中，这样可以与最后一步的交换提供帮助，\verb|sret|则返回到用户态。


用户态切换到内核态，用户态从这里开始陷入。函数指针在从内核态返回到用户态之前被写到 stvec 寄存器里面去，但是目前页表仍然还是用户态的页表。先对用户态的上下文进行保存，然后在进行页表的切换。

\begin{lstlisting}[caption=由用户态进入内核态]
pub unsafe extern "C" fn user_to_supervisor() -> ! {
    core::arch::asm!(
        "csrrw  a0, sscratch, a0",
        "
        // ... 保存 SwapContext ..
    ",
        "csrr   t0, sscratch
        sd      t0, 9*8(a0)",
        "csrr   t0, sepc
        sd      t0, 34*8(a0)",
        "ld     sp, 32*8(a0)",
        "ld     tp, 35*8(a0)",
        "ld     t0, 33*8(a0)",
        // "csrr   t2, satp",
        "ld     t1, 31*8(a0)
        csrw    satp, t1",
        "sfence.vma",
        "jr     t0",
        options(noreturn)
    );
}
\end{lstlisting}


与内核态进入用户态的过程相似，首先保存交换栈的顶指针，将sepc寄存器写到SwapContext的相应位置之后，则恢复内核栈的指针，并将用户中断处理函数入口存入t0，和用户的satp寄存器存入t2，之后恢复内核的页表，最后进入中断处理函数。

\subsection{进程通信}

\begin{table}[htb]
    \tableCapSet    % 使用此命令调整 caption 间距
    \caption{tiny 进程通信的系统调用}
    \label{table:c4tinyprocesssyscall}
    \centering
    \zihao{5}
    \begin{tabular}{c|c|c}
        \hlineB{3}  % 线宽为3倍的横线
        编号  & 系统调用               & 功能描述                \\
        \hlineB{2}  % 线宽为2倍的横线
            1 &sys\_yield &暂时放弃执行 \\
            \hline
            2 &sys\_getpid &获取进程id \\
            \hline
            3 &sys\_fork &创建子进程 \\
            \hline
            4 &sys\_exec &执行新程序 \\
            \hline
            5 &sys\_waitpid &等待子进程结束 \\
            \hline
            6 &sys\_pipe &创建管道 \\
            \hline
            7 &sys\_kill &发送信号给某进程 \\
            \hline
            8 &sys\_sigaction &设立信号处理例程 \\
            \hline
            9 &sys\_sigprocmask &设置要阻止的信号 \\
            \hline
            10 &sys\_sigreturn &从信号处理例程返回 \\
            \hline
            11 &sys\_sleep &进程休眠一段时间 \\
            \hline
        \hlineB{3}
    \end{tabular}
\end{table}


\subsection{文件系统}

\begin{table}[htb]
    \tableCapSet    % 使用此命令调整 caption 间距
    \caption{tiny 文件系统主要的系统调用}
    \label{table:c4tinyfssyscall}
    \centering
    \zihao{5}
    \begin{tabular}{c|c|c}
        \hlineB{3}  % 线宽为3倍的横线
        编号  & 系统调用               & 功能描述                \\
        \hlineB{2}  % 线宽为2倍的横线
            1 &sys\_write &输出字符串/写文件 \\
            \hline
            2 &sys\_read &读取字符串/读文件 \\
            \hline
            3 &sys\_open &打开/创建文件 \\
            \hline
            4 &sys\_close &关闭文件 \\
            \hline
        \hlineB{3}
    \end{tabular}
\end{table}

\subsection{并发处理}

\begin{table}[htb]
    \tableCapSet    % 使用此命令调整 caption 间距
    \caption{tiny 并发系统调用}
    \label{table:c4tinyconcurrencysyscall}
    \centering
    \zihao{5}
    \begin{tabular}{c|c|c}
        \hlineB{3}  % 线宽为3倍的横线
        编号  & 系统调用               & 功能描述                \\
        \hlineB{2}  % 线宽为2倍的横线
            1 &sys\_thread\_create &创建线程 \\
            \hline
            2 &sys\_gettid &获取线程id \\
            \hline
            3 &sys\_waittid &等待线程结束 \\
        \hlineB{3}
    \end{tabular}
\end{table}

\subsubsection{互斥锁}

\begin{table}[htb]
    \tableCapSet    % 使用此命令调整 caption 间距
    \caption{tiny 锁机制系统调用}
    \label{table:c4tinymutexsyscall}
    \centering
    \zihao{5}
    \begin{tabular}{c|c|c}
        \hlineB{3}  % 线宽为3倍的横线
        编号  & 系统调用               & 功能描述                \\
        \hlineB{2}  % 线宽为2倍的横线
            1 &sys\_mutex\_create &创建锁 \\
            \hline
            2 &sys\_mutex\_lock &获取锁 \\
            \hline
            3 &sys\_mutex\_unlock &释放锁 \\
        \hlineB{3}
    \end{tabular}
\end{table}

\subsubsection{条件变量}

\begin{table}[htb]
    \tableCapSet    % 使用此命令调整 caption 间距
    \caption{tiny 条件变量系统调用}
    \label{table:c4tinycondvarsyscall}
    \centering
    \zihao{5}
    \begin{tabular}{c|c|c}
        \hlineB{3}  % 线宽为3倍的横线
        编号  & 系统调用               & 功能描述                \\
        \hlineB{2}  % 线宽为2倍的横线
            1 &sys\_condvar\_create &创建条件变量 \\
            \hline
            2 &sys\_condvar\_signal &唤醒阻塞在条件变量上的线程 \\
            \hline
            3 &sys\_condvar\_wait &阻塞与此条件变量关联的当前线程 \\
        \hlineB{3}
    \end{tabular}
\end{table}

\subsubsection{信号量}

\begin{table}[htb]
    \tableCapSet    % 使用此命令调整 caption 间距
    \caption{tiny 信号量系统调用}
    \label{table:c4tinysemaphonesyscall}
    \centering
    \zihao{5}
    \begin{tabular}{c|c|c}
        \hlineB{3}  % 线宽为3倍的横线
        编号  & 系统调用               & 功能描述                \\
        \hlineB{2}  % 线宽为2倍的横线
            1 &sys\_semaphore\_create &创建信号量 \\
            \hline
            2 &sys\_semaphore\_up &减少信号量的计数 \\
            \hline
            3 &sys\_semaphore\_down &增加信号量的计数 \\
        \hlineB{3}
    \end{tabular}
\end{table}

\section{异步调度}

\subsection{用户空间和内核空间的异步执行逻辑}

\begin{lstlisting}[caption=用户空间的异步逻辑]
pub fn execute_async() {
    let shared_payload = unsafe { task::shared::SharedPayload::new(SHARED_PAYLOAD_BASE) };
    task::shared::run_until_ready(
        || unsafe { shared_payload.peek_task(task::shared::user_should_switch) },
        |task_repr| unsafe { shared_payload.delete_task(task_repr) },
        |task_repr, new_state| unsafe { shared_payload.set_task_state(task_repr, new_state) },
    );
}
\end{lstlisting}

得益于共享调度的设计，ring\_scheduler的物理地址无论在内核空间还是用户空间都是可见的，因此内核和用户可以通过run\_until\_ready来执行相应的异步任务， 即从ring\_scheduler中获取任务， 将任务(指针)存入调度器，改变调度器中原有任务的任务状态。


\subsection{异步事件的底层依赖: Event}

需要设计一个事件监听的工具，使得可以将同步的数据结构转化为异步的数据结果，为异步提供基础的依赖。

异步事件的内部同步的数据结构为:

\begin{lstlisting}[caption=异步事件底层的同步结构]
struct Inner {
    notified: AtomicUsize,
    list: Mutex<List>,
    cache: UnsafeCell<Entry>,
}
\end{lstlisting}

Inner中的notified用于通知已被通知的Entry的数目，如果所有条目都被通知了，或者没有条目被通知，该值都会被设置为usize::MAX。而list则是用于指向已被注册的监听的链表， 而Mutex提供在多线程中list资源的锁机制，以解决资源竞争带来的数据冲突。

\subsubsection{异步事件的一些原语}
\label{sssec:event}

\begin{lstlisting}[caption = 监听者的注册]
pub fn listen(&self) -> EventListener {
    let inner = self.inner();
    let listener = EventListener {
        inner: unsafe { Arc::clone(&ManuallyDrop::new(Arc::from_raw(inner))) },
        entry: Some(inner.lock().insert(inner.cache_ptr())),
    };

    // Make sure the listener is registered before whatever happens next.
    full_fence();
    listener
}
\end{lstlisting}

\begin{lstlisting}[caption = 通知一定数量的监听者]
pub fn notify(&self, n: usize) {
    full_fence();
    if let Some(inner) = self.try_inner() {
        if inner.notified.load(Ordering::Acquire) < n {
            inner.lock().notify(n);
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption = 通知一定数量没有被通知的监听者]
pub fn notify_additional(&self, n: usize) {
    full_fence();

    if let Some(inner) = self.try_inner() {
        if inner.notified.load(Ordering::Acquire) < usize::MAX {
            inner.lock().notify_additional(n);
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption=full\_fence]
fn full_fence() {
    core::sync::atomic::fence(Ordering::SeqCst);
}
\end{lstlisting}

full\_fence 该函数会阻止编译器和CPU围绕对某些类型的内春操作重新排序。使其可以在一些原子操作中创建同步关系。

\subsubsection{Event异步事件的状态}
\begin{lstlisting}[caption=Event的状态]
enum State {
    /// 刚刚被创建
    Created,
    /// 已经接收到一个通知
    ///
    /// 如果这是个 `additional` 通知，`bool` 将为 `true`
    Notified(bool),
    /// 正在被一个异步任务 `poll`，保存了任务的 `waker`
    Polling(Waker),
}
\end{lstlisting}

只用当状态为`State::Notified(bool)`的时候，事件才是被通知， 因此有如下的事件监听机制：

\begin{lstlisting}[caption=Event的事件获取并判断事件是否完成]
impl Future for EventListener {
    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        let mut list = self.inner.lock();

        let entry = match self.entry {
            None => unreachable!("cannot poll a completed `EventListener` future"),
            Some(entry) => entry,
        };
        // ...
    }
}
\end{lstlisting}


\begin{lstlisting}[caption=Event的事件Poll机制]
impl Future for EventListener {
    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // ...
        let state = unsafe { &entry.as_ref().state };
        match state.replace(State::Notified(false)) {
            State::Notified(_) => {
                list.remove(entry, self.inner.cache_ptr());
                drop(list);
                self.entry = None;
                return Poll::Ready(());
            }
            State::Created => {
                state.set(State::Polling(cx.waker().clone()));
            }
            State::Polling(w) => {
                if w.will_wake(cx.waker()) {
                    state.set(State::Polling(w));
                } else {
                    state.set(State::Polling(cx.waker().clone()));
                }
            }
        }
        Poll::Pending
    }
}
\end{lstlisting}


当获取事件的状态的可变引用时， 当章台为Polling和Created的时候，事件将会被加入到注册的waker序列中，当为Notified时，事件将会从序列中移除，然后释放相应的资源，并返回Ready告知任务已经完成，其余状态统一返回Pending
