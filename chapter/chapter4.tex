\chapter{系统实现}
\label{chap:SystemImplement}

\section{内核}

\subsection{内存管理}
\subsubsection{地址空间的映射}

\begin{lstlisting}[caption=用户态对地址空间的映射]
pub async fn prepare_user<S: Into<String>>(user: S, kernel_stack_top: usize) {
    let user: String = user.into();
    let mut user_memory = load_user(&user).await;
    let user_asid = user_memory.address_space_id.into_inner();
    let swap_cx_va = VirtualAddress(swap_contex_va(user_asid));
    let swap_cx_vpn = VirtualPageNumber::floor(swap_cx_va);
    let swap_cx_ppn = user_memory
        .mapping
        .translate(swap_cx_vpn)
        .unwrap()
        .page_number();
    let swap_cx = unsafe {
        (swap_cx_ppn .start_address() .0 .wrapping_add(KERNEL_MAP_OFFSET) as *mut trap::SwapContext) .as_mut() .unwrap()
    };
    let _user_satp = user_memory.mapping.get_satp(user_memory.address_space_id);
    let user_stack_handle = user_memory .alloc_page_range(STACK_SIZE, Flags::READABLE | Flags::WRITABLE | Flags::USER) .expect("alloc user stack");

    let user_stack_top = user_stack_handle.end.0;
    assert!( KernelHartInfo::load_user_mm_set(user_memory), "try load memory set with exited");
    let kernel_satp = satp::read().bits();
    let tp = hart::read_tp();
    *swap_cx = trap::SwapContext::new_to_user( kernel_satp, 0, tp, kernel_stack_top, user_stack_top, user_trap_handler as usize,);
    swap_cx.set_gp(crate::SHAREDPAYLOAD_BASE);
    swap_cx.set_tp(user_asid);
}
\end{lstlisting}


\subsubsection{内核态与用户态之间的转化}

\begin{lstlisting}[caption=由内核态进入用户态]
pub unsafe extern "C" fn supervisor_to_user() -> ! {
    core::arch::asm!(
        "csrw   satp, a1
        sfence.vma", // 刷新页表
        // 从 SwapContext 中恢复用户的上下文
        // 将用户的 a0 寄存器保存在 sscratch 寄存器中，
        // 这样子可以在最后一步将它和 a0（ctx） 进行交换
        "
        ld      t0, 9*8(a0)
        csrw    sscratch, t0
        ",
        "
        // ... 恢复通用寄存器的上下文 ...
        ",
        // 恢复用户的 a0 寄存器，并且保存交换栈顶在 sscratch 寄存器中
        "csrrw  a0, sscratch, a0",
        // 返回到用户态
        "sret",
        options(noreturn)
    )
}

\end{lstlisting}


用户态切换到内核态，用户态从这里开始陷入。函数指针在从内核态返回到用户态之前被写到 stvec 寄存器里面去，但是目前页表仍然还是用户态的页表。先对用户态的上下文进行保存，然后在进行页表的切换。

\begin{lstlisting}[caption=由用户态进入内核态]
pub unsafe extern "C" fn user_to_supervisor() -> ! {
    core::arch::asm!(
        // 交换 a0 和 sscratch（原先保存着交换栈的栈顶指针）
        "csrrw  a0, sscratch, a0",
        "
        // ... 保存 SwapContext ..
    ",
        // 保存用户的 a0 寄存器
        "csrr   t0, sscratch
    sd      t0, 9*8(a0)",
        // 写 sepc 寄存器到 SwapContext 中相应位置
        "csrr   t0, sepc
        sd      t0, 34*8(a0)",
        // 恢复内核栈指针
        "ld     sp, 32*8(a0)",
        // todo: 如何处理 tp 寄存器
        "ld     tp, 35*8(a0)",
        // 将用户中断处理函数指针放到 t0 寄存器
        "ld     t0, 33*8(a0)",
        // // 将用户的 satp 寄存器放到 t2 寄存器里面去
        // "csrr   t2, satp",
        // 恢复内核页表
        "ld     t1, 31*8(a0)
        csrw    satp, t1",
        "sfence.vma",
        // 跳转到中断处理函数
        "jr     t0",
        options(noreturn)
    );
}
\end{lstlisting}

\subsection{进程通信}

\begin{table}[htb]
    \tableCapSet    % 使用此命令调整 caption 间距
    \caption{tiny 进程通信的系统调用}
    \label{table:c4tinyprocesssyscall}
    \centering
    \zihao{5}
    \begin{tabular}{c|c|c}
        \hlineB{3}  % 线宽为3倍的横线
        编号  & 系统调用               & 功能描述                \\
        \hlineB{2}  % 线宽为2倍的横线
            1 &sys\_yield &暂时放弃执行 \\
            \hline
            2 &sys\_getpid &获取进程id \\
            \hline
            3 &sys\_fork &创建子进程 \\
            \hline
            4 &sys\_exec &执行新程序 \\
            \hline
            5 &sys\_waitpid &等待子进程结束 \\
            \hline
            6 &sys\_pipe &创建管道 \\
            \hline
            7 &sys\_kill &发送信号给某进程 \\
            \hline
            8 &sys\_sigaction &设立信号处理例程 \\
            \hline
            9 &sys\_sigprocmask &设置要阻止的信号 \\
            \hline
            10 &sys\_sigreturn &从信号处理例程返回 \\
            \hline
            11 &sys\_sleep &进程休眠一段时间 \\
            \hline
        \hlineB{3}
    \end{tabular}
\end{table}


\subsection{文件系统}

\begin{table}[htb]
    \tableCapSet    % 使用此命令调整 caption 间距
    \caption{tiny 文件系统主要的系统调用}
    \label{table:c4tinyfssyscall}
    \centering
    \zihao{5}
    \begin{tabular}{c|c|c}
        \hlineB{3}  % 线宽为3倍的横线
        编号  & 系统调用               & 功能描述                \\
        \hlineB{2}  % 线宽为2倍的横线
            1 &sys\_write &输出字符串/写文件 \\
            \hline
            2 &sys\_read &读取字符串/读文件 \\
            \hline
            3 &sys\_open &打开/创建文件 \\
            \hline
            4 &sys\_close &关闭文件 \\
            \hline
        \hlineB{3}
    \end{tabular}
\end{table}

\subsection{并发处理}

\begin{table}[htb]
    \tableCapSet    % 使用此命令调整 caption 间距
    \caption{tiny 并发系统调用}
    \label{table:c4tinyconcurrencysyscall}
    \centering
    \zihao{5}
    \begin{tabular}{c|c|c}
        \hlineB{3}  % 线宽为3倍的横线
        编号  & 系统调用               & 功能描述                \\
        \hlineB{2}  % 线宽为2倍的横线
            1 &sys\_thread\_create &创建线程 \\
            \hline
            2 &sys\_gettid &获取线程id \\
            \hline
            3 &sys\_waittid &等待线程结束 \\
        \hlineB{3}
    \end{tabular}
\end{table}

\subsubsection{互斥锁}

\begin{table}[htb]
    \tableCapSet    % 使用此命令调整 caption 间距
    \caption{tiny 锁机制系统调用}
    \label{table:c4tinymutexsyscall}
    \centering
    \zihao{5}
    \begin{tabular}{c|c|c}
        \hlineB{3}  % 线宽为3倍的横线
        编号  & 系统调用               & 功能描述                \\
        \hlineB{2}  % 线宽为2倍的横线
            1 &sys\_mutex\_create &创建锁 \\
            \hline
            2 &sys\_mutex\_lock &获取锁 \\
            \hline
            3 &sys\_mutex\_unlock &释放锁 \\
        \hlineB{3}
    \end{tabular}
\end{table}

\subsubsection{条件变量}

\begin{table}[htb]
    \tableCapSet    % 使用此命令调整 caption 间距
    \caption{tiny 条件变量系统调用}
    \label{table:c4tinycondvarsyscall}
    \centering
    \zihao{5}
    \begin{tabular}{c|c|c}
        \hlineB{3}  % 线宽为3倍的横线
        编号  & 系统调用               & 功能描述                \\
        \hlineB{2}  % 线宽为2倍的横线
            1 &sys\_condvar\_create &创建条件变量 \\
            \hline
            2 &sys\_condvar\_signal &唤醒阻塞在条件变量上的线程 \\
            \hline
            3 &sys\_condvar\_wait &阻塞与此条件变量关联的当前线程 \\
        \hlineB{3}
    \end{tabular}
\end{table}

\subsubsection{信号量}

\begin{table}[htb]
    \tableCapSet    % 使用此命令调整 caption 间距
    \caption{tiny 信号量系统调用}
    \label{table:c4tinysemaphonesyscall}
    \centering
    \zihao{5}
    \begin{tabular}{c|c|c}
        \hlineB{3}  % 线宽为3倍的横线
        编号  & 系统调用               & 功能描述                \\
        \hlineB{2}  % 线宽为2倍的横线
            1 &sys\_semaphore\_create &创建信号量 \\
            \hline
            2 &sys\_semaphore\_up &减少信号量的计数 \\
            \hline
            3 &sys\_semaphore\_down &增加信号量的计数 \\
        \hlineB{3}
    \end{tabular}
\end{table}

\section{异步调度}

\subsection{用户空间的异步执行逻辑}

\begin{lstlisting}[caption=用户空间的异步逻辑]
pub fn execute_async() {
    let shared_payload = unsafe { task::shared::SharedPayload::new(SHARED_PAYLOAD_BASE) };
    task::shared::run_until_ready(
        || unsafe { shared_payload.peek_task(task::shared::user_should_switch) },
        |task_repr| unsafe { shared_payload.delete_task(task_repr) },
        |task_repr, new_state| unsafe { shared_payload.set_task_state(task_repr, new_state) },
    );
}
\end{lstlisting}

\subsection{内核空间的异步执行逻辑}

这部分的逻辑，还没有实现。


\subsection{异步事件的底层依赖: Event}

需要设计一个事件监听的工具，使得可以将同步的数据结构转化为异步的数据结果，为异步提供基础的依赖。

异步事件的内部同步的数据结构为:

\begin{lstlisting}[caption=异步事件底层的同步结构]
struct Inner {
    notified: AtomicUsize,
    list: Mutex<List>,
    cache: UnsafeCell<Entry>,
}
\end{lstlisting}

Inner中的notified用于通知已被通知的Entry的数目，如果所有条目都被通知了，或者没有条目被通知，该值都会被设置为usize::MAX。而list则是用于指向已被注册的监听的链表， 而Mutex提供在多线程中list资源的锁机制，以解决资源竞争带来的数据冲突。

\subsubsection{异步事件的一些原语}
\label{sssec:event}

\begin{lstlisting}[caption = 监听者的注册]
pub fn listen(&self) -> EventListener {
    let inner = self.inner();
    let listener = EventListener {
        inner: unsafe { Arc::clone(&ManuallyDrop::new(Arc::from_raw(inner))) },
        entry: Some(inner.lock().insert(inner.cache_ptr())),
    };

    // Make sure the listener is registered before whatever happens next.
    full_fence();
    listener
}
\end{lstlisting}

\begin{lstlisting}[caption = 通知一定数量的监听者]
pub fn notify(&self, n: usize) {
    full_fence();
    if let Some(inner) = self.try_inner() {
        if inner.notified.load(Ordering::Acquire) < n {
            inner.lock().notify(n);
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption = 通知一定数量没有被通知的监听者]
pub fn notify_additional(&self, n: usize) {
    full_fence();

    if let Some(inner) = self.try_inner() {
        if inner.notified.load(Ordering::Acquire) < usize::MAX {
            inner.lock().notify_additional(n);
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption=full\_fence]
fn full_fence() {
    core::sync::atomic::fence(Ordering::SeqCst);
}
\end{lstlisting}

full\_fence 该函数会阻止编译器和CPU围绕对某些类型的内春操作重新排序。使其可以在一些原子操作中创建同步关系。

\subsubsection{Event异步事件的状态}
\begin{lstlisting}[caption=Event的状态]
enum State {
    /// 刚刚被创建
    Created,
    /// 已经接收到一个通知
    ///
    /// 如果这是个 `additional` 通知，`bool` 将为 `true`
    Notified(bool),
    /// 正在被一个异步任务 `poll`，保存了任务的 `waker`
    Polling(Waker),
}
\end{lstlisting}

只用当状态为`State::Notified(bool)`的时候，事件才是被通知， 因此有如下的事件监听机制：

\begin{lstlisting}[caption=Event的事件监听机制, numbers=left]
impl Future for EventListener {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        let mut list = self.inner.lock();

        let entry = match self.entry {
            None => unreachable!("cannot poll a completed `EventListener` future"),
            Some(entry) => entry,
        };
        let state = unsafe { &entry.as_ref().state };

        match state.replace(State::Notified(false)) {
            State::Notified(_) => {
                list.remove(entry, self.inner.cache_ptr());
                drop(list);
                self.entry = None;
                return Poll::Ready(());
            }
            State::Created => {
                state.set(State::Polling(cx.waker().clone()));
            }
            State::Polling(w) => {
                if w.will_wake(cx.waker()) {
                    state.set(State::Polling(w));
                } else {
                    state.set(State::Polling(cx.waker().clone()));
                }
            }
        }

        Poll::Pending
    }
}
\end{lstlisting}

EventListener中的poll函数, 
