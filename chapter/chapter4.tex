\chapter{系统实现}
\label{chap:SystemImplement}

\section{内核}

\subsection{KernelHartInfo}
\begin{lstlisting}[caption=KernelHartInfo的结构]
#[repr(C)]
pub struct KernelHartInfo {
    hart_id: usize,
    // ...
    asid_alloc: (LinkedList<usize>, usize),   // (空余的编号回收池，目前已分配最大的编号)
    user_mm_sets: (LinkedList<MemorySet>, usize), // (注册的用户地址空间映射，上一次进入的用户地址空间编号)
}
\end{lstlisting}

KernelHartInfo游走在内核态和用户态之间。记录了如CPU的核心编号， 用户空间的地址映射信息，地址分配的信息等等。

\subsection{地址空间的映射}

\begin{lstlisting}[caption=用户态对地址空间的映射]
pub async fn prepare_user<S: Into<String>>(user: S, kernel_stack_top: usize) {
    let user: String = user.into();
    let mut user_memory = load_user(&user).await;
    let user_asid = user_memory.address_space_id.into_inner();
    let swap_cx_va = VirtualAddress(swap_contex_va(user_asid));
    let swap_cx_vpn = VirtualPageNumber::floor(swap_cx_va);
    let swap_cx_ppn = user_memory
        .mapping
        .translate(swap_cx_vpn)
        .unwrap()
        .page_number();
    let swap_cx = unsafe {
        (swap_cx_ppn .start_address() .0 .wrapping_add(KERNEL_MAP_OFFSET) as *mut trap::SwapContext) .as_mut() .unwrap()
    };
    let _user_satp = user_memory.mapping.get_satp(user_memory.address_space_id);
    let user_stack_handle = user_memory .alloc_page_range(STACK_SIZE, Flags::READABLE | Flags::WRITABLE | Flags::USER) .expect("alloc user stack");

    let user_stack_top = user_stack_handle.end.0;
    assert!( KernelHartInfo::load_user_mm_set(user_memory), "try load memory set with exited");
    let kernel_satp = satp::read().bits();
    let tp = hart::read_tp();
    *swap_cx = trap::SwapContext::new_to_user( kernel_satp, 0, tp, kernel_stack_top, user_stack_top, user_trap_handler as usize,);
    swap_cx.set_gp(crate::SHAREDPAYLOAD_BASE);
    swap_cx.set_tp(user_asid);
}
\end{lstlisting}


\subsection{内核态与用户态之间的转化}

\begin{lstlisting}[caption=由内核态进入用户态]
pub unsafe extern "C" fn supervisor_to_user() -> ! {
    core::arch::asm!(
        "csrw   satp, a1
        sfence.vma", // 刷新页表
        // 从 SwapContext 中恢复用户的上下文
        // 将用户的 a0 寄存器保存在 sscratch 寄存器中，
        // 这样子可以在最后一步将它和 a0（ctx） 进行交换
        "
        ld      t0, 9*8(a0)
        csrw    sscratch, t0
        ",
        "
        // ... 恢复通用寄存器的上下文 ...
        ",
        // 恢复用户的 a0 寄存器，并且保存交换栈顶在 sscratch 寄存器中
        "csrrw  a0, sscratch, a0",
        // 返回到用户态
        "sret",
        options(noreturn)
    )
}

\end{lstlisting}


用户态切换到内核态，用户态从这里开始陷入。函数指针在从内核态返回到用户态之前被写到 stvec 寄存器里面去，但是目前页表仍然还是用户态的页表。先对用户态的上下文进行保存，然后在进行页表的切换。

\begin{lstlisting}[caption=由用户态进入内核态]
pub unsafe extern "C" fn user_to_supervisor() -> ! {
    core::arch::asm!(
        // 交换 a0 和 sscratch（原先保存着交换栈的栈顶指针）
        "csrrw  a0, sscratch, a0",
        "
        // ... 保存 SwapContext ..
    ",
        // 保存用户的 a0 寄存器
        "csrr   t0, sscratch
    sd      t0, 9*8(a0)",
        // 写 sepc 寄存器到 SwapContext 中相应位置
        "csrr   t0, sepc
        sd      t0, 34*8(a0)",
        // 恢复内核栈指针
        "ld     sp, 32*8(a0)",
        // todo: 如何处理 tp 寄存器
        "ld     tp, 35*8(a0)",
        // 将用户中断处理函数指针放到 t0 寄存器
        "ld     t0, 33*8(a0)",
        // // 将用户的 satp 寄存器放到 t2 寄存器里面去
        // "csrr   t2, satp",
        // 恢复内核页表
        "ld     t1, 31*8(a0)
        csrw    satp, t1",
        "sfence.vma",
        // 跳转到中断处理函数
        "jr     t0",
        options(noreturn)
    );
}
\end{lstlisting}


\section{异步I/O}

\subsection{异步事件的底层依赖: Event}

需要设计一个事件监听的工具，使得可以将同步的数据结构转化为异步的数据结果，为异步提供基础的依赖。

异步事件的内部同步的数据结构为:

\begin{lstlisting}[caption=异步事件底层的同步结构]
struct Inner {
    notified: AtomicUsize,
    list: Mutex<List>,
    cache: UnsafeCell<Entry>,
}
\end{lstlisting}

Inner中的notified用于通知已被通知的Entry的数目，如果所有条目都被通知了，或者没有条目被通知，该值都会被设置为usize::MAX。而list则是用于指向已被注册的监听的链表， 而Mutex提供在多线程中list资源的锁机制，以解决资源竞争带来的数据冲突。

\subsubsection{异步事件的一些原语}
\label{sssec:event}

\begin{lstlisting}[caption = 监听者的注册]
pub fn listen(&self) -> EventListener {
    let inner = self.inner();
    let listener = EventListener {
        inner: unsafe { Arc::clone(&ManuallyDrop::new(Arc::from_raw(inner))) },
        entry: Some(inner.lock().insert(inner.cache_ptr())),
    };

    // Make sure the listener is registered before whatever happens next.
    full_fence();
    listener
}
\end{lstlisting}

\begin{lstlisting}[caption = 通知一定数量的监听者]
pub fn notify(&self, n: usize) {
    full_fence();
    if let Some(inner) = self.try_inner() {
        if inner.notified.load(Ordering::Acquire) < n {
            inner.lock().notify(n);
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption = 通知一定数量没有被通知的监听者]
pub fn notify_additional(&self, n: usize) {
    full_fence();

    if let Some(inner) = self.try_inner() {
        if inner.notified.load(Ordering::Acquire) < usize::MAX {
            inner.lock().notify_additional(n);
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption=full\_fence]
fn full_fence() {
    core::sync::atomic::fence(Ordering::SeqCst);
}
\end{lstlisting}

full\_fence 该函数会阻止编译器和CPU围绕对某些类型的内春操作重新排序。使其可以在一些原子操作中创建同步关系。

\subsubsection{Event异步事件的状态}
\begin{lstlisting}[caption=Event的状态]
enum State {
    /// 刚刚被创建
    Created,
    /// 已经接收到一个通知
    ///
    /// 如果这是个 `additional` 通知，`bool` 将为 `true`
    Notified(bool),
    /// 正在被一个异步任务 `poll`，保存了任务的 `waker`
    Polling(Waker),
}
\end{lstlisting}

只用当状态为`State::Notified(bool)`的时候，事件才是被通知， 因此有如下的事件监听机制：

\begin{lstlisting}[caption=Event的事件监听机制, numbers=left]
impl Future for EventListener {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        let mut list = self.inner.lock();

        let entry = match self.entry {
            None => unreachable!("cannot poll a completed `EventListener` future"),
            Some(entry) => entry,
        };
        let state = unsafe { &entry.as_ref().state };

        match state.replace(State::Notified(false)) {
            State::Notified(_) => {
                list.remove(entry, self.inner.cache_ptr());
                drop(list);
                self.entry = None;
                return Poll::Ready(());
            }
            State::Created => {
                state.set(State::Polling(cx.waker().clone()));
            }
            State::Polling(w) => {
                if w.will_wake(cx.waker()) {
                    state.set(State::Polling(w));
                } else {
                    state.set(State::Polling(cx.waker().clone()));
                }
            }
        }

        Poll::Pending
    }
}
\end{lstlisting}

EventListener中的poll函数, 

\section{模块化}