\chapter{系统设计}
\label{chap:SystemDesign}

系统设计主要包含系统内存的设计，异步的设计和模块化的设计。

\section{系统内核}

\subsection{内核提供的系统调用}


\begin{table}[htb]
    \tableCapSet    % 使用此命令调整 caption 间距
    \caption{tiny 系统调用}
    \label{table:c3tinysyscall}
    \centering
    \zihao{5}
    \begin{tabular}{c|c|c}
        \hlineB{3}  % 线宽为3倍的横线
        编号  & 系统调用               & 功能描述                \\
        \hlineB{2}  % 线宽为2倍的横线
            1&sys\_exit&结束执行 \\
            \hline
            2&sys\_write&输出字符串/写文件 \\
            \hline
            3&sys\_yield&暂时放弃执行 \\
            \hline
            4&sys\_get\_time&获取当前时间 \\
            \hline
            5&sys\_getpid&获取进程id \\
            \hline
            6&sys\_fork&创建子进程 \\
            \hline
            7&sys\_exec&执行新程序 \\
            \hline
            8&sys\_waitpid&等待子进程结束 \\
            \hline
            9&sys\_read&读取字符串/读文件 \\
            \hline
            10&sys\_open&打开/创建文件 \\
            \hline
            11&sys\_close&关闭文件 \\
            \hline
            12&sys\_dup&复制文件描述符 \\
            \hline
            13&sys\_pipe&创建管道 \\
            \hline
            14&sys\_kill&发送信号给某进程 \\
            \hline
            15&sys\_sigaction&设立信号处理例程 \\
            \hline
            16&sys\_sigprocmask&设置要阻止的信号 \\
            \hline
            17&sys\_sigreturn&从信号处理例程返回 \\
            \hline
            18&sys\_sleep&进程休眠一段时间 \\
            \hline
            19&sys\_thread\_create&创建线程 \\
            \hline
            20&sys\_gettid&获取线程id \\
            \hline
            21&sys\_waittid&等待线程结束 \\
            \hline
            22&sys\_mutex\_create&创建锁 \\
            \hline
            23&sys\_mutex\_lock&获取锁 \\
            \hline
            24&sys\_mutex\_unlock&释放锁 \\
            \hline
            25&sys\_semaphore\_create&创建信号量 \\
            \hline
            26&sys\_semaphore\_up&减少信号量的计数 \\
            \hline
            27&sys\_semaphore\_down&增加信号量的计数 \\
            \hline
            28&sys\_condvar\_create&创建条件变量 \\
            \hline
            29&sys\_condvar\_signal&唤醒阻塞在条件变量上的线程 \\
            \hline
            30&sys\_condvar\_wait&阻塞与此条件变量关联的当前线程 \\
        \hlineB{3}
    \end{tabular}
\end{table}

参考已有的操作系统设计本论文所写的操作系统将尝试实现\autoref{table:c3tinysyscall}相应的系统调用，以完成一个具有基本系统功能的微内核（内存管理、进行通信、文件系统、并发管理）。

\subsection{内存管理}

应用程序中，动态内存分配，依赖系统所管理的堆。其设计上应当有如下功能：

\begin{itemize}
\item 初始时能提供内存空间作为初始的堆内存。在没有分页机制情况下，堆是物理内存，否则就是虚拟的。\pagescite{rcore0}
\item 提供分配和释放内存的函数接口。调用方通过分配接口得到内存块，也能通过释放接口回收空间。\pagescite{rcore0}
\item 提供空间管理的分配算法。动态地维护空闲和已分配的内存。\pagescite{rcore0}
\item （可选）提供建立在堆上的数据结构和操作。有了分配与释放接口，就可以实现动态数组，动态字典等空间灵活可变的数据结构。\pagescite{rcore0}
\end{itemize}

\subsubsection{GlobalAlloc}
Rust的GlobalAlloc需要在no\_std的环境中提供一个全局的动态内存管理，Rust\pagescite{rust0}将利用分配器来管理空间，使得与堆相关的智能指针或容器数据结构可以正常工作。具体而言，内存管理接口需要如下约束：

\begin{lstlisting}[caption=GlobalAlloc的Trait约束]
pub unsafe fn alloc(&self, layout: Layout) -> *mut u8;
pub unsafe fn dealloc(&self, layout: Layout);
\end{lstlisting}

当完成Heap的接入的时候，在no\_std的环境中任然还需要为其提供, 当动态内存分配失败时，系统的处理函数, 简单处理，让\verb|#[alloc_error_handler]|直接返回\verb|panic|的异常。

\subsubsection{地址空间}

地址空间，从某种程度上讲，可以将它看成一块巨大但并不一定真实存在的内存。在应用程序中，系统分配给应用一个地址范围，且独占的连续空间，因此应用程序可以在划分给它的地址空间中随意规划内存布局，它的各个段也就可以分别放置在地址空间中它希望的位置（当然是操作系统允许应用访问的地址）。应用也可以使用地址作为索引来读写自己空间的数据，就类似于用物理地址作为索引来读写物理内存上的数据。这种地址被称为虚拟地址。


\subsubsection{分页管理}

具体的分页逻辑参考\autoref{figure:c2addressv2p}, 其思路来自Riscv平台下的Sv39的地址转换。

内核以页为单位进行物理内存管理，应用的地址空间会被分成若干个虚拟页面，而物理内存同样可以被分成若干个物理页帧，页面和页帧大小相同，每个虚拟页面中的数据实际上都存储在某个物理页帧上。\pagescite{riscv0}

为了方便实现虚拟页面到物理页帧的地址转换，标记每个虚拟页面和物理页帧一个编号，分别称为 虚拟页号和物理页号。每个应用都有一个表示地址映射关系的 页表 (Page Table) ，里面记录了该应用地址空间中的每个虚拟页面映射到物理内存中的哪个物理页帧，即数据实际被内核放在哪里。\pagescite{rcore0}

如果将页表看成一个键值对，其键的类型为虚拟页号，值的类型则为物理页号。\pagescite{rcore0}当内存控制单元进行地址转换，虚拟地址会分为两部分（虚拟页号，页内偏移），内存控制单元先找到虚拟地址的虚拟的页号，然后查当前应用的页表，根据虚拟页号找到物理页号；\pagescite{rcore0}最后按照虚拟地址的页内偏移，给物理页号对应的物理页帧的起始地址加上一个偏移量，这就得到了实际访问的物理地址。

\subsubsection{内核与应用地址的空间分配}

在分页模式开启之后，CPU先拿到虚存，通过内存管理单元的地址转换变成物理地址，再给CPU去访问物理内存。地址空间抽象的重要意义在于空间隔离 ，当应用执行前，内核需要内存控制单元，这个应用的多级页表进行地址转换。\pagescite{rcore0}而应用地址空间在创建的时候也顺带设置好了多级页表，使得只有那些存放了它的代码和数据的物理页帧能够通过该多级页表被映射到，这样它就只能访问自己的代码和数据而无法触及其他应用或内核的内容。\pagescite{rcore0}

启用分页模式下，内核代码的地址也会被看成一个虚拟地址并经过内存管理单元的地址转换，因此需要为内核构造一个地址空间，它除了允许内核的各数据段能够被正常访问之后，还应包含所有应用的内核栈以及一个跳板 (Trampoline) 。

通常在内核空间中跳板放在最高的一个虚拟页面中,因为分页机制的关系，使得每次发生Trap的时候，Riscv的satp的会发生改变，而trap的异常处理函数只有在内核空间中才能被访问，因此如此设计可以设计在地址空间切换时指令能够被正确执行。接下来则是从高到低放置每个应用的内核栈。

应用空间，效仿内核地址空间的设计，同样借助页表机制使得应用地址空间的各个逻辑段也可以有不同的访问方式限制，这样可以提早检测出应用的错误并及时将其终止以最小化它对系统带来的恶劣影响。

\subsubsection{Yield系统调用}

需要知道当前所处的地址空间，用户的上下文，还要相应的地址映射关系。由于内核空间和用户空间之间的转换是通过跳板页实现的，因此用户的上下文，将会被存放在跳板也的数据段中，而在分页机制的情况下，相应上下文的地址可以通过相应的公式计算出来（用户可以获取一页的空间保存上下文）。

参考tornado-os的设计，利用tp寄存器，由其指向一个存有KernelHartInfo的地址。而用户的地址空间映射就被包存在这里。

\begin{lstlisting}[caption=KernelHartInfo的结构]
#[repr(C)]
pub struct KernelHartInfo {
    hart_id: usize,
    // ...
    asid_alloc: (LinkedList<usize>, usize),   // (空余的编号回收池，目前已分配最大的编号)
    user_mm_sets: (LinkedList<MemorySet>, usize), // (注册的用户地址空间映射，上一次进入的用户地址空间编号)
}
\end{lstlisting}

KernelHartInfo游走在内核态和用户态之间。记录了如CPU的核心编号， 用户空间的地址映射信息，地址分配的信息等等。

\subsection{进程通信}
% TODO: Need Fix
为了在用户态可以借助系统服务灵活管理、控制应用执行，可以在已有的任务抽象基础做一些拓展，形成新的抽象：进程 ，并实现若干基于其的系统调用。\pagescite{rcore0}

\begin{itemize}
\item 创建：父进程创建子进程。用户在终端键入命令或用鼠标点击应用程序，调用系统服务来创建进程，运行程序。\pagescite{rcore0}
\item 销毁：进程销毁。进程在运行完成后可自行退出，但还需要其他进程来回收相应资源。\pagescite{rcore0}
\item 等待：父进程等待子进程退出。\pagescite{rcore0}
\item 信息：获取进程的状态信息。\pagescite{rcore0}
\item 其他：其他的进程控制服务。\pagescite{rcore0}
\end{itemize}

参照rcore\pagescite{rcore0}的设计， 进程模型有三个运行状态：就绪态、运行态和等待态；有基于独立页表的地址空间；可被操作系统调度来分时占用 CPU 执行；可以动态创建和退出；可通过系统调用获得操作系统的服务。与之对应的一些重要的结构。

\begin{itemize}
\item 进程标识符和内核栈：组成进程控制块的重要部分。
\item 任务控制块：进程的主要数据结构。
\item 任务管理器：管理进程的主要数据结构。
\item 处理器管理结构：进程调度，维护进程的处理器状态。
\end{itemize}

从而与之对应的重要的功能

\begin{itemize}
\item 初始进程：创建第一个用户态进程；
\item 进程调度：当进程主动调用yield\pagescite{rcore0}交出CPU使用权或者内核把本轮分配的时间片用尽的进程换出且换入下一个进程；
\item 进程生成：两个重要系统调用fork/exec的实现；
\item 进程资源回收：当进程调用exit\pagescite{rcore0}正常退出或者出错被内核终止之后如何保存其退出码，其父进程通过waitpid系统调用收集该进程的信息并回收其资源。
\item 字符输入：通过shell获得字符输入；\pagescite{rcore0}
\end{itemize}

内核初始化完毕之后会调用task模块中的启用进程初始化函数将初始进程加入任务管理器。\pagescite{rcore0}通过task模块提供的任务切换原语暂停当前任务并切换到下一个任务，此时会调用yield主动交出使用权，当本轮时间片用尽或者由于某些原因内核中的处理无法继续的时候，就会在内核中调用此函数触发调度机制并进行任务切换。

在内核中手动生成的进程只有初始进程，余下的进程都是直接或间接由初始进程fork出来。\pagescite{rcore0}当一个子进程被fork之后，其可以调用exec来加载并执行另一个可执行文件。\pagescite{rcore0}因此，fork/exec\pagescite{rcore0}两个系统调用提供了进程的生成机制。

在子进程内核栈上压入一个初始化的任务上下文，使得内核一旦通过任务切换到该进程，就会跳转进入用户态。\pagescite{rcore0}在复制地址空间的时候，子进程的地址空间上下文也是完全从父进程复制过来的，由此可以保证子进程父进程回到用户态的那一瞬间CPU的状态是完全相同的。\pagescite{rcore0}由于地址空间是复制的，所以两个进程的应用数据也是完全相同的。

waitpid\pagescite{rcore0}是一个立即返回的系统调用，它的返回值语义是：如果当前的进程不存在一个进程则返回-1；如果存在一个进程编号为pid的僵尸子进程，则正常回收并返回子进程的pid，并更新系统调用的退出码参数为 exit\_code 。这里还有一个 -2 的返回值，它的含义是子进程还没退出，通知用户库，当用户库看到是-2后，就进一步调用yield系统调用，让当前父进程进入等待状态。

基于基本的进程模型，本文尝试实现操作系统中管道和信号机制。为进程通行提供相应的系统原语。两者的定义如下文所述。

% TODO: Need Fix
\subsubsection{管道}


管道是一种进程间通信机制，由操作系统提供，并可通过直接编程或在shell程序的帮助下轻松地把不同进程（目前是父子进程之间或子子进程之间）的输入和输出对接起来。也可以将管道看成一个有缓冲区大小的队列，分为读、写两端，通过不同的文件描述符来访问。\pagescite{rcore0}

读端用来从管道中读取，而写端用来将数据写入。\pagescite{rcore0}管道是一个队列，读取数据则从队头弹，写入数据则把数据写入队尾。\pagescite{rcore0}由于管道的缓冲区大小是有限的，一旦缓冲区被填满就无法继续写入，需要等到队列弹出数据后才能继续写入。当缓冲区为空的时候，读端自然也不能继续从里面读取数据，需要等到写端写入了一些数据之后才能继续读取。

\subsubsection{信号}

信号是操作系统中实现进程间通信的一种机制，用来通知进程一个特定事件已经发生，需要处理。\pagescite{rcore0}当一个信号发送给一个进程时，操作系统会中断接收到信号的进程的正常执行流程并对信号进行处理。\pagescite{rcore0}如果该进程定义了信号的处理函数，那么这个处理函数会被调用，否则就执行默认的处理行为，比如让该进程退出。\pagescite{rcore0}在处理完信号之后，如果进程还没有退出，则会恢复并继续进程的正常执行。

\subsection{文件系统}

文件系统,在类Unix系统设计中，文件这个概念的提出是具有划时代意义的。文件是对设备的高度抽象，尤其是对存储结构的抽象，使得这个读写是文件的读写相互绑定简化了磁盘控制提高了系统读写数据的能力。文件系统参考遵循rcore的easy-fs设计，进行实现。

\subsubsection{文件}

从用户的角度看，常规文件是在持久存储设备上的字节序列，每个常规文件都有一个文件名 ，通过其来区分不同的文件。\pagescite{rcore0}方便起见，在下面的描述中，“文件”有可能指的是常规文件、目录，也可能是之前提到的若干种进程可以读写的 标准输出、标准输入、管道等I/O 资源，请同学自行根据上下文判断取哪种含义。

\subsubsection{目录}

早期的文件系统通过文件名来区分文件，但是这会造成一些归档和管理上的困难。如今的使用习惯是将文件根据功能、属性的不同分类归档到不同层级的目录之下。这样就很容易逐级找到想要的文件。结合用户和用户组的概念，目录的存在也使得文件访问权限控制更加容易，只需要对于目录进行设置就可以间接获得用户集合对目录下文件的访问，使得系统能够更加安全的支持多用户对不同文件的操作需求。

\subsubsection{文件的读写和权限结构}

\begin{lstlisting}[caption=文件系统基本读写]
pub trait File: Send + Sync {
    fn readable(&self) -> bool;
    fn writable(&self) -> bool;
    fn read(&self, buf: UserBuffer) -> usize;
    fn write(&self, buf: UserBuffer) -> usize;
}
\end{lstlisting}

\begin{itemize}
\item r 表示是否允许获取目录下的文件和目录；\pagescite{rcore0}
\item w 表示是否允许在目录下创建和删除文件或子目录；\pagescite{rcore0}
\item x 表示是否允许进入目录。\pagescite{rcore0}
\end{itemize}


\subsubsection{Easy-fs\pagescite{rcore0}的磁盘布局}

\begin{figure}[htb]
    \figureCapSet
    \centering
    \includegraphics[width=.8\linewidth]{figure/c3/easyfsdevicemap.png}
    \caption{Easy Fs 的磁盘布局}
    \label{figure:c3easyfsdevicemap}
\end{figure}


顶层的块，其是文件系统的超级块，以魔数的形式提供文件系统合法性检查，同时还具有定位其他连续区域的功能。\pagescite{rcore0}

第二个区域是一个索引节点位图，记录了后面区域中节点使用的使用情况。\pagescite{rcore0}

第三个区域是索引节点区域，其中的每个块都存储了若干个索引节点。\pagescite{rcore0}

第四个区域是一个数据块位图，记录了后面的数据块区域的使用情况。\pagescite{rcore0}

最后的区域则是数据块区域，其每个已分配的块保存了文件或目录中的具体数据内容。\pagescite{rcore0}


\subsection{并发处理}

线程是进程的组成部分，进程可包含多个线程，同一个进程的线程共享进程资源。\pagescite{rcore0} 进程是程序的执行单元，是程序对数据集合进行操作的一次过程，是系统进行资源分配和调度的基本。线程提出后，进程则是线程的资源容器，线程是程序的基本执行实体。\pagescite{rcore0}

数据不一致性、不确定的计算结果，意味在操作系统的执行过程中，可能存在并发问题，并导致程序或操作系统执行失败。我们先给出 线程的数据一致性 的定义：在单处理器（即只有一个核的CPU）下，如果某线程更新了一个可被其他线程读到的共享数据，那么后续其他线程都能读到这个最新被更新的数据。

当多个线程共享同一进程的地址空间时，每个线程都可以访问属于这个进程的数据（全局变量）。\pagescite{rcore0}如果每个线程使用到的变量是其他线程无法操作的，则各个线程访问的变量和其结果都是可以预估的，就不存在资源竞争的问题。\pagescite{rcore0}如果变量是只读的，也不会存在一致性问题。

当两个以上的线程尝试竞争访问同一资源时，执行结果将是未定义的，其取决于不可预知的执行顺序，这种情况称为 线程的竞态条件。该问题可能导致应用程序或操作系统执行失败。而线程的数据不一致问题和竞态条件问题的根本原因是调度的不可控性 ：即读写共享变量的代码片段会随时可能被操作系统调度和切换。

常见处理资源竞争的解决方案有互斥锁，条件变量以及信号量。

\subsubsection{互斥锁}

互斥锁是操作系统中用于保护共享资源的机制。互斥锁能够确保在任何时候只有一个线程访问共享资源，从而避免资源竞争导致的数据不一致的问题。在获取互斥锁的时候，线程会被挂起，直到另一个线程释放了锁。

\subsubsection{条件变量}

条件变量是操作系统中的一种同步原语，可用于在多个线程之间进行协作，即允许一个线程在另一个线程完成某些操作之前等待。条件变量与互斥锁经常一起使用，以保证在同一时刻只有一个线程在访问共享资源。

线程通过更改布尔值并通知条件变量来发送信号，而主线程则使用条件变量来等待信号。首先，定义一个元组 (Mutex<bool>, Condvar)，使用 Arc\pagescite{rust0}将其包装在一个共享的指针中。这个指针会产生两个副本，两个线程都可以访问这个元组。\pagescite{rcore0}然后，启动一个新的线程，并在这个线程内部使用互斥锁来更改共享的布尔值。最后，它使用条件变量来等待这个布尔值被更改，最后退出循环。

\subsubsection{信号量}

信号量是操作系统中的一种同步原语，用于在多个线程或进程之间共享资源时进行互斥访问。它通常是一个整数值，用于计数指定数量的资源可用。当一个线程需要使用资源时，它会执行信号量的获取操作，如果信号量的值小于等于零，则线程将压入阻塞队列，（信号量的值变为正数，则会弹出，即唤醒）；否则将信号量的值减少，操作正常返回。另一方面，当一个线程完成使用资源后，它可以执行信号量的释放操作，将信号量的值加一，并唤醒一个或所有挂起的线程。

\section{异步调度}

\subsection{ring\_scheduler}


ring\_scheduler中的黑盒调度任务池资源，同时为内核和用户提供一系列的数据接口，实现任务资源在内核态和用户态两者之间的统一调度。

\subsubsection{元数据}

元数据是ring\_scheduler基本的调度单位

\begin{itemize}
\item hart\_id: 运行该任务的硬件线程编号，简单化为核的ID号
\item address\_space\_id: 地址空间编号
\item task\_repr: 任务指针，由所在的地址空间解释为任务
\item state: 任务状态
\end{itemize}


address\_space\_id指示任务地址，在分页机制下，通过KernelHartInfo，取得地址空间的映射关系，找到任务执行的物理地址。

task\_repr是任务指针，内核空间和用户空间的任务在ring\_scheduler由其指代，同时只有当task\_repr通过正确的地址转换才能得到正确的任务结构。

如果任务指针在其他地址空间尝试被解析，那么极会触发缺页异常，即使发生转换，其数据也是未定义的，不合法的。得益于指令集设计上的地址空间隔离的作用，使得任务指针在实现上存在一定的安全性。


state标记这个任务的状态，至少会有两种状态的存在：就绪与睡眠。就绪状态的任务表示该任务的某个阶段已经准备好可以进一步执行；睡眠状态的任务表示该任务需要等待一些数据或者其他任务的完成，处于等待状态。

就绪状态的任务可以被ring\_scheduler弹出交给内核或用户运行，睡眠状态的任务只有被唤醒器唤醒之后才能转成就绪状态，然后被进一步执行。

\subsubsection{ring\_scheduler的接口}

\begin{lstlisting}[caption=调度器的接口约束]
pub trait Scheduler<T: Clone + PartialEq> {
    type Priority;
    fn add_task(&mut self, task: T) -> Option<T>;
    fn peek_next_task(&self) -> Option<&T>;
    fn peek_next_task_mut(&mut self) -> Option<&mut T>;
    fn next_task(&mut self) -> Option<T>;
    fn current_task(&self) -> Option<T>;
    fn remove_task(&mut self, task: &T);
    fn set_priority(&mut self, task: T, priority: Self::Priority);
    fn queue_len(&self) -> Option<usize> {
        None
    }
}
\end{lstlisting}


\begin{itemize}
\item add\_task：尝试向调度器中添加一个任务
\item peek\_next\_task：获取下一个任务不可变的引用
\item peek\_next\_task\_mut：获取下一个任务可变的引用
\item next\_task： 得到下一个任务
\item current\_task：获取正在运行的当前任务，在发生中断时，通过这个保存任务的上下文
\item remove\_task：从调度器中移除一个任务
\item set\_priority： 设置任务的优先级，没有实现
\item queue\_len：返回队列的长度，如果不存在，则返回None
\end{itemize}


\subsubsection{先来先服务的队列处理方式}

这里采用最简单的任务调度算法，ring\_scheduler的底层实现了一个循环队列用以存储相应的任务结构，和相应的一些操作。底层队列的长度将是固定的，当队列中的任务处于唤醒时或队列已经放不下相应任务时，ring\_scheduler会将相应任务弹出，对于后者则阻止新任务的队列加入。

\subsection{异步}

调度器和执行器是分离的。调度器只根据元数据调度，得到下一个任务是什么。而这个任务该如何运行，调度器不知道，需要交给执行器来解释元数据的意义，拿到异步结构之后运行。

\subsubsection{任务的状态}

\begin{equation}
    \label{equation:c3taskstate}
    \begin{aligned}
\boldsymbol{\mathrm{TaskState}} = (\mathrm{Ready}, \mathrm{Sleeping}, \mathrm{Finished})^{\mathrm{T}}
    \end{aligned}
\end{equation}

其中，任务有TaskRepr的指针传递进来， 其中如果状态为Ready时， 表示任务可以执行，应当被ring\_scheduler弹出。Sleeping则表示任务处于休眠状态， 当ring\_scheduler中的任务睡眠的程度到达内核约束的值或，应当由内核通过一定方式尝试唤醒适量的任务。最后， Finished则表示任务已经完成。

\subsubsection{共享的数据}

参考元数据， $\boldsymbol{\mathrm{Task}} := (\mathrm{hartId}, \mathrm{addressSpaceId}, \mathrm{taskRepr}, \mathrm{State})^{\mathrm{T}}$。为了使得内核和用户态的任务可以得到共享，因此内核态和用户态的任务都应当有如下描述：

\begin{lstlisting}
struct Task {
    pub id: TaskId,
    pub process: Arc<Process>,
    pub inner: Mutex<TaskInner>,
    pub future: Mutex<Pin<Box<dyn Future<Output = ()> + 'static + Send + Sync>>>, 
}
\end{lstlisting}

\subsubsection{执行器的实现}

由于调度器和执行器是分离的，调度器只知道任务的运行状态，而不知道该如何对任务进行操作。因此后半部分的工作将需要执行器的介入，而执行器的工作依赖于调度器的返回，若执行器返回遵循以下的规则

\begin{equation}
    \label{equation:c3schedulerreturn}
    \begin{aligned}
\boldsymbol{\mathrm{SchedulerReturn}} = (\mathrm{TaskRepr}, \mathrm{SholdYield}, \mathrm{NoWakeTask}, \mathrm{Finished})^{\mathrm{T}}
    \end{aligned}
\end{equation}

其中

\begin{itemize}
    \item TaskRepr, 应当立即执行特定任务, 执行器从调度器获得这个值的时候需要调用相关方法释放任务,如果不释放任务，再次执行，还是会得到相同的任务。
    \item ShouldYield, 其他地址空间的任务要运行，应当提示执行器主动让出，并携带下一个地址空间信息。与此同时用户态应该执行yield，保存当前用户上下文，并切换至内核转到下一个地址空间。
    \item  NoWakeTask，调度器里面没有醒着的任务，但存在睡眠的任务。
    \item  Finished，队列已空，所有任务已经结束。
\end{itemize}


内核执行器的设计

在一个大循环中，不断从共享调度器中拿到任务，对任务进行poll操作，如果返回Ready，从共享调度器中删除该任务，如果返回Pending，将该任务设置为睡眠状态。如果共享调度器中所有任务都已完成，则退出系统。

\begin{lstlisting}[caption=内核执行器的设计]
pub fn run_until_idle() {
    loop {
        let task = peek_task(); // 从共享调度器中拿出下一个任务的指针，不弹出
        match task {
            TaskResult::Task(task_repr: usize) => { // 任务指针
                set_task_state(task_repr, TaskState::Sleeping); // 设置任务的状态为睡眠
                let task: Arc<KernelTask> = unsafe { Arc::from_raw(task_repr as *mut _) };
                // 注册 waker
                let waker = waker_ref(&task);
                let mut context = Context::from_waker(&*waker);
                let ret = task.future.lock().as_mut().poll(&mut context);
                if let Poll::Pending = ret {
                    core::mem::forget(task); // 不要释放task的内存，它将继续保存在内存中被使用
                } else {
                    // 否则，从共享调度器中删除此任务
                    delete_task(task_repr);
                } // 隐含一个drop(task)
            },
            TaskResult::ShouldYield(next_asid: usize) => {...}, // 不同地址空间的任务，需要切换地址空间
            TaskResult::NoWakeTask => {...},
            TaskResult::Finished => {...}
        }
    }
}
\end{lstlisting}

用户执行器的设计

用户执行器的设计和内核执行器存在一点区别，就是当拿到不在当前地址空间的任务的时候，不释放这个任务的内存，执行切换地址空间的系统调用。

\begin{lstlisting}[caption=用户执行器的设计]
pub fn run_until_idle() {
    loop {
        let task = peek_task(); // 从共享调度器中拿出下一个任务的指针，不弹出
        match task {
            TaskResult::Task(task_repr: usize) => {...},
            TaskResult::ShouldYield(next_asid: usize) => {
                mem::forget(task);
                do_yield(next_asid);
            },
            TaskResult::NoWakeTask => {...},
            TaskResult::Finished => {...}
        }
    }
}
\end{lstlisting}

\section{模块设计}

\subsection{静态模块}

在静态模块的设计中，系统模块设计应当遵循以下原则：

\begin{enumerate}
    \item 最小正交化的模块
    \item 树状依赖和空间隔离
\end{enumerate}

\subsubsection{最小正交的模块}


\begin{figure}[htb]
    \figureCapSet
    \centering
    \includegraphics[width=.8\linewidth]{figure/c3/starfishstructure.png}
    \caption{Starfish 的静态模块分解图}
    \label{figure:c3starfishstructure}
\end{figure}

参考\autoref{figure:c3starfishstructure}，这是最开始设计的内核模块的静态的拆分图。为了方便描述，每一层定义为抽象层级，处在最底层的其抽象层级为0，层级越低抽象的能力越小，反之则越大。而每一层的节点可以定义为抽象因子。例如，Starfish Config为0层的抽象因子，其寓意为在该层级的最小正交因子（即在当前的抽象下，该因子为最小的不可再分割的正交参考）。

正交，顾名思义就是将一个复杂的“合力”,通过相应的参考系，进行有序分解，形成一个可以通过参考系中的相应因子描述的矢量，例如 $\boldsymbol {v}=(a, b)$， 则可以准确表述矢量$\boldsymbol {v}$在直角坐标系中的空间表示。

类比前者，提出抽象正交化的概念，我们将整个抽象空间则概括为由抽象层级和抽象因子组成的抽象评估空间，其空间的单位为抽象评估因子，则可以得到如下式子，


\begin{equation}
    \label{equation:c3elf}
    \begin{aligned}
       \boldsymbol{\mathrm{E}} = (L, F)
    \end{aligned}
\end{equation}

其中$\boldsymbol{E}$表示评估因子，L表示抽象层级，F表示抽象因子。由此可以总结出两组概念：最小正交化和严格最小正交化。

\begin{enumerate}
    \item 最小正交化： 当$L=0$时，即抽象层级为0，即模块不可再分的情况下， $\boldsymbol{E}$为最小正交化的评估因子，此时模块分解为最小正交化。
    \item 严格最小正交化： 在满足最小正交化的前提下， 有$F = {F_{0}, F_{1}, \cdots, F_{n}}$，其中$0 = {F_{0} \cap F_{1} \cap \cdots \cap F_{n}}$, 此时， $\boldsymbol{E}$为严格正交化的评估因子，此时模块分解为严格最小正交化。
\end{enumerate}

当$\boldsymbol{E}$为严格正交化时，则可以说模块分解达到了一个最优的状态，此时所有的$L=0$级的模块之间不存在互相干扰的情况，彼此之间的联系，仅仅通过语言编程者之间的API约束，如此的好处可以使得模块之间的耦合程度变低，相互之间可以独立进行开发，同时如果他人的内核也遵循了相应的API约束，则该模块可以达到共享的目的。


\subsubsection{树状依赖和空间隔离}


通过\autoref{figure:c3starfishstructure}的观察，可以发现模块的分解和组合，其静态的模块将会形成一种树状的结果，此时L(即抽象层级)之间是存在“方向”的，即当存在$L_{i} < L_{j} (i < j)$时， $L_{j}$必然是由部分$L_{i}$组成，而必不可能存在上下互换的生成形式，如若L的层级方向出现错误，则$\boldsymbol{E}$将无法做出评估，其模块拆解也必然是错误的。由此，一个良好的模块分解必然会形成一个层次分明的树状依赖。

当L一定， $F = {F_{0}, F_{1}, \cdots, F_{n}}$时， 若有$0 = {F_{0} \cap F_{1} \cap \cdots \cap F_{n}}$，此时的$\boldsymbol{E}$可以达到最优解，即优化评估因子，记作$\boldsymbol{OE}$，特别地当 $L = 0$时，若形成$\boldsymbol{OE}$，即$F$达到分解地最优解，则此时就可以称为严格最小正交化。

其中$\boldsymbol{OE}$的意义是，层级间的依赖被解除，模块是独立，没有相互干扰, 可以达到层级空间间的空间隔离。同样以此可以逆向评估底层模块的$\boldsymbol{E}$特性， 通过数学归纳法，我们可以显而易见的得出当$L_{i} < L_{j} (i < j)$, 若$L_{j}$达到了$\boldsymbol{OE}$，则$L_{i}$也应当是$\boldsymbol{OE}$的。

\subsection{动态模块}

在动态模块的设计中，系统的模块设计应当遵循以下三个原则： \begin{enumerate}
    \item 需要获取所有模块的运行时的持久边界
    \item 最大限度地发挥语言（Rust）和编译器的作用
    \item 最小化模块之间的状态溢出
\end{enumerate}

\subsubsection{需要获取所有模块的运行时的持久边界}

系统内核中的模块组件具有明确定义的边界（严格化的正交模块），并在整个运行时保持不变： 在实现时，系统模块组件以Rust独立的Crate的形式存在；在编译时，系统模块组件以一组加载的内存区域的形式存在；在运行时，系统模块组件以一组加载内存区域的形式存在，内存区域具有每部分的边界和依赖元数据。

上述的设计原则每一个内核的系统模块组件都需要遵循。运行时，可以显示识别系统模块组件的边界是系统内核中组件隔离和状态管理的基础。

在运行时，系统内核根据需要将所有系统模块组件加载并链接到系统中。简而言之，这需要找到并解析系统模块组件对象，将其部分加载到内存中，解析其依赖，根据依赖树，以写入连接器重定位条目，根据需要递归加载任何丢失的系统模块组件，并向符号映射添加新的公共符号。基于此可以为内核进化和故障恢复提供理论基础。加载的系统模块组件集定义了一个系统模块组件空间，一个包含所有系统模块组件公共符号的真正的名称空间，用于快速解析单元格之间的依赖关系。每个加载的系统模块组件节点跟踪其组成部分和存储区域包含它们。每个系统模块组件中的部分对应于其Crate的目标文件中的部分，例如，可执行文件、只读数据和读写数据部分。每个加载的分段节点跟踪其大小、在存储器中的位置以及双向依赖性(输入和输出)；额外的元数据用于加速系统模块组件交换和其他系统功能。

系统模块组件边界的持久性降低了复杂性: 系统内核的持久性系统模块组件边界在其存在的所有阶段提供了一致的系统结构抽象。这将会降低了开发者对系统的理想模型的复杂性，并简化了故障恢复和演化逻辑，因为系统内核可以在运行时从相同的面向系统模块组件的角度自省和管理它自己的代码。从顶层应用程序和库到核心内核组件的一切都可以作为系统模块组件来观察。这使得系统内核能够

\begin{itemize}
	\item 实现统一适用于任何单元的单一机制，即模块交换，以及
	\item 以安全的方式从多个系统层(例如，应用和内核组件)联合进化模块。
\end{itemize}

\subsubsection{最大限度地发挥语言（Rust）和编译器的作用}
通过使编译器能够最大限度地检查安全性和正确性不变量来最大限度发挥语言的力量。

将系统内核的执行环境与该语言的运行时模型相匹配，并在Rust等现代语言提供的强大的静态类型系统中实现操作系统概念。这将编译器检查的不变量(例如，没有悬空引用)扩展到了所有类型的资源，而不仅仅是语言中内置的那些。

依赖语言设计有两个主要好处：

\begin{itemize}
    \item 首先，它使编译器能够接管资源管理职责，减少了操作系统必须维护的状态，从而减少了状态溢出并加强了隔离。
    \item 它使编译器能够在理解代码行为的过程中应用安全检查，从应用程序到核心内核组件实现端到端安全，并将语义运行时错误转化为编译时错误。
\end{itemize}

相比之下，传统的非语言方法依赖于硬件保护和运行时检查来维护安全性、隔离性和正确性的不变量。这些特性对编译器是透明的，需要不安全的代码。甚至现有的安全语言操作系统。在语言级别的安全代码和底层的不安全核心之间有一个缺口，后者将语言所需的抽象实现为一个黑盒。

\subsubsection{最小化模块之间的状态溢出}

由于系统内核的组件结构是模块化的，因此状态溢出只能发生在跨越模块边界并导致接收单元状态改变的交互(例如，函数调用)中。
