\chapter{前置知识}
\label{chap:knowledge}

\section{Rust：依赖语言的程序设计}

Rust 是一门十分高效的编程语言， 其设计目的是在编译时提供强大的类型和内存安全保证，它将高级托管语言的强大功能和表达能力与类似c语言的无垃圾收集或底层运行时的效率相结合。编写操作系统可以利用Rust的许多特性来实现语言内、安全的操作系统设计，并使用crate (Rust的项目容器和翻译单元)实现源代码级模块化。而Cargo.toml包含源代码和依赖项清单。编写操作系统是没有使用Rust的标准库，但使用了它的基本核心和alloc库。

Rust的所有权模型是其编译时内存安全和管理的关键。所有权基于仿射类型，其中一个值最多只能使用一次。在Rust中，每个值都有一个所有者，例如，下面的代码中分配的字符串值“hello!”由hello变量拥有。在一个值被移动之后，例如，如果“hello!”在第5行中被从hello移动到owned\_string (第14行)，它的所有权将被转移，之前的所有者(hello)将不能再使用它。

\begin{lstlisting}[caption=Rust Demo]
fn main() {
	let hel: &str;
	{
		let hello = String::from("hello!");
		// consume(hello); // -> "value moved" error in here.
		let borrowed_str: &str = &hello;
		hel = substr(borrowed_str);
		// println!("{}", hel); // -> lifetime error
	}
}
fn substr<'a> (input_str: &'a str) -> &'a str {
	&input_str[0..3] // return value has lifetime 'a
}
fn consume(owned_string: String) { }
\end{lstlisting}


当所有者的作用域结束时，例如，在词法块的末尾，通过编译器插入对其析构函数的调用，所有者的值将被丢弃(释放)。Rust中的析构函数是通过实现给定类型的Drop特征来实现的，其中自定义的Drop处理程序可以执行除释放内存之外的任意操作。在上面的第8行中，hello字符串超出了作用域，并由它的删除处理程序自动释放。

还可以通过 borrow 来获得对它们的引用(第6行)，而且这些引用的生命周期不能超过所拥有值的生命周期。第11行中的语法将input\_str参数的生命期命名为'a，并指定返回的\&str引用具有相同的生命期'a。返回的\&str引用在第7行中被赋值给hel，这将在第9行中由于生命周期的原因而被释放，因为在第8行中，hel将在它最初从(hello)借来的拥有值被删除后使用。Rust的编译器包括一个借用检查器来执行这些生命周期规则，以及别名异或可变性的核心原则，其中可以有多个不可变引用，也可以有单个对值的可变引用，但不能同时存在这两个引用。这允许它静态地确保堆栈和堆上的值的内存安全。

系统设计还广泛利用了Rust泛型的特征，是一种抽象类型的声明，它指定了类型必须实现的方法集，类似于OOP语言中的多态接口。trait可用于在泛型类型参数上设置边界。例如，函数fn print\_str<T: Into<String>>(s: T){}，其中<T: Into<String>约束了入参s的类型，其必须实现Into<String>的泛型特征, 如果s没有符合类型约束则在代码编译时就会被抛出错误。

\section{操作系统}

\subsection{Riscv}

\subsubsection{Riscv的机器模式}

risc-v架构定义了3种工作模式，又称为特权模式（privileged mode）。

\begin{itemize}
    \item 机器模式（machine mode），简称M模式；
    \item 监督模式（supervisor mode），简称S模式；
    \item 用户模式（user mode），简称U模式。
\end{itemize}

Riscv架构定义机器模式为必选模式，另外两种模式为可选模式，通过不同的模式组合可以实现不同的系统。其中机器模式拥有最高的权限，而用户模式的权限则是最低的，权限高的模式对于权限低的模式是透明的，权限低的无法获得权限高的所拥有的资源。从而达到了层与层之间的隔离，设计上指令集是安全的。

SBI（Supervisor Binary Interface）是Supervisor Execution Environment (SEE)和supervisor之间的接口。 它允许主管通过使用 ecall 指令执行一些特权操作。 SEE 和 supervisor 的示例有：Unix 类平台上的 M-Mode 和 S-Mode，其中 SBI 是它们之间的唯一接口，以及 Hypervisor extended-Supervisor (HS) 和 Virtualized Supervisor (VS)。

\subsubsection{Sv39\pagescite{xv60}}

\textbf{地址格式与组成}

\begin{figure}[htb]
    \figureCapSet
    \centering
    \includegraphics[width=.8\linewidth]{figure/c2/addressstructure.png}
    \caption{Sv39的地址格式}
    \label{figure:c2addressstructure}
\end{figure}

采用分页管理，单个页面的大小设置为 4KiB ，每个虚拟页面和物理页帧都对齐到这个页面大小，也就是说虚拟/物理地址区间 [0,4KiB) 为第 0 个虚拟页面/物理页帧，而 [4KiB,8KiB) 为第 1 个，以此类推。 4KiB 需要用 12 位字节地址来表示，因此虚拟地址和物理地址都被分成两部分：它们的低 12 位，即 [11:0] 被称为 页内偏移 (Page Offset) ，它描述一个地址指向的字节在它所在页面中的相对位置。而虚拟地址的高 27 位，即 [38:12] 为它的虚拟页号 VPN，同理物理地址的高 44 位，即 [55:12] 为它的物理页号 PPN，页号可以用来定位一个虚拟/物理地址属于哪一个虚拟页面/物理页帧。

地址转换是以页为单位进行的，在地址转换的前后地址的页内偏移部分不变。可以认为 MMU 只是从虚拟地址中取出 27 位虚拟页号，在页表中查到其对应的物理页号（如果存在的话），最后将得到的44位的物理页号与虚拟地址的12位页内偏移依序拼接到一起就变成了56位的物理地址。


\textbf{地址转换过程}

\begin{figure}[htb]
    \figureCapSet
    \centering
    \includegraphics[width=.8\linewidth]{figure/c2/addressv2p.png}
    \caption{Sv39地址转换过程}
    \label{figure:c2addressv2p}
\end{figure}

在 SV39 模式中，采用三级页表，即将 27 位的虚拟页号分为三个等长的部分，第 26-18 位为一级页索引 VPN0 ，第 17-9 位为二级页索引 VPN1 ，第 8-0 位为三级页索引 VPN2 。

页表分为一级页表（多级页表的根节点），二级页表，三级页表（多级页表的叶节点）。每个页表都用 9 位索引，因此有 $2^9=512$ 个页表项，而每个页表项都是 8 字节，因此每个页表大小都为 $512\times 8=4 \mathrm{KiB}$ 。正好是一个物理页的大小。从而可以把一个页表放到一个物理页中，并用一个物理页号来描述它。事实上，一级页表的每个页表项中的物理页号可描述一个二级页表；二级页表的每个页表项中的物理页号可描述一个三级页表；三级页表中的页表项内容则和先前提到的页表项一样，包含物理页号，即描述一个要映射到的物理页。

具体来说，假设有虚拟地址$(VPN_{0} ,VPN_{1},VPN_{2},offset)$：
	首先会记录装载「当前所用的一级页表的物理页」的页号到 satp 寄存器中；
    \begin{itemize}
	\item 把 $VPN_{0}$ 作为偏移在一级页表的物理页中找到二级页表的物理页号；
	\item 把 $VPN_{1}$ 作为偏移在二级页表的物理页中找到三级页表的物理页号；
	\item 把 $VPN_{2}$ 作为偏移在三级页表的物理页中找到要访问位置的物理页号；
    \end{itemize}

	物理页号对应的物理页基址（即物理页号左移12位）加上 offset 就是虚拟地址对应的物理地址。

这样处理器通过这种多次转换，终于从虚拟页号找到了一级页表项，从而得出了物理页号和虚拟地址所对应的物理地址。刚才我们提到若页表项满足 R,W,X 都为 0，表明这个页表项指向下一级页表。在这里三级和二级页表项的 R,W,X 为 0 应该成立，因为它们指向了下一级页表。


\subsection{API与ABI}

从使用操作系统的角度会比较容易对操作系统内核的功能产生初步的认识。操作系统内核是一个提供各种服务的软件，其服务对象是应用程序，而用户是通过应用程序的服务间接获得操作系统的服务的，因此操作系统内核在一般用户面前是一个透明地。但应用程序需要访问操作系统获得操作系统的服务，这就需要通过操作系统的接口才能完成。操作系统与运行在用户态软件之间的接口形式就是应用程序二进制接口 (ABI, Application Binary Interface)。

操作系统不能只提供面向单一编程语言的函数库的编程接口 (API, Application Programming Interface) ，它的接口需要考虑对基于各种编程语言的应用支持，以及访问安全等因素，使得应用软件不能像访问函数库一样的直接访问操作系统内部函数，更不能直接读写操作系统内部的地址空间。为此，操作系统设计了一套安全可靠的二进制接口，即系统调用接口 (System Call Interface)。系统调用接口通常面向应用程序提供了 API 的描述，但在具体实现上，还需要提供 ABI 的接口描述规范。

在现代处理器的安全支持（特权级隔离，内存空间隔离等）下，应用程序就不能直接以函数调用的方式访问操作系统的函数，和直接读写操作系统的数据变量。不同类型的应用程序可以通过符合操作系统规定的系统调用接口，发出系统调用请求，来获得操作系统的服务。操作系统提供完服务后，返回应用程序继续执行。

\subsubsection{API 与 ABI 的区别}

应用程序二进制接口ABI是不同二进制代码片段的连接纽带。ABI定义了二进制机器代码级别的规则，主要包括基本数据类型、通用寄存器的使用、参数的传递规则、以及堆栈的使用等等。ABI与处理器和内存地址等硬件架构相关，是用来约束链接器 (Linker) 和汇编器 (Assembler) 的。在同一处理器下，基于不同高级语言编写的应用程序、库和操作系统，如果遵循同样的ABI定义，那么它们就能正确链接和执行。

应用程序编程接口API是不同源代码片段的连接纽带。API定义了一个源码级（如C语言）函数的参数，参数的类型，函数的返回值等。因此API是用来约束编译器 (Compiler) 的：一个API是给编译器的一些指令，它规定了源代码可以做以及不可以做哪些事。API与编程语言相关，如libc是基于C语言编写的标准库，那么基于C的应用程序就可以通过编译器建立与libc的联系，并能在运行中正确访问libc中的函数。


\section{异步}

\begin{lstlisting}[ caption = BREAKFIRST ]
enum FoodState {
    Cooked,
    Eating,
    Finished,
};
async fn milk () { /* ... */ }
async fn bread () { /* ... */ }
async fn eat () {
    /* ... */
    milk.await;
    bread.await;
    /* ... */
}

\end{lstlisting}



\begin{figure}[htb]
    \figureCapSet
    \centering
    \includegraphics[width=.8\linewidth]{figure/c2/breakfirststate.png}
    \caption{Breakfirst的状态机图}
    \label{figure:c2breakfirststate}
\end{figure}


\begin{figure}[htbp]
    \figureCapSet
	\centering
	\begin{minipage}{0.49\linewidth}%表示图片的占用那一列的宽度
		\centering
        \begin{lstlisting}[frame=none]
async fn eating(min_energy: usize) -> String {
    let food = async_eat("milk").await;
    if food.energy() < min_energy {
        content + &async_eat("bread").await
    } else {
        content
    }
}
        \end{lstlisting}
	\end{minipage}
    \hfill
	%\hfill表示横向排，两张图片会自动保证一定的距离
    %\vfill表示自动排版，两张图片会自动保证一定的距离
    %或者直接在这里加空格来增加图片之间的距离
	\begin{minipage}{0.49\linewidth}
		\centering
        \begin{lstlisting}[frame=none]
enum BreakfirstStateMachine {
    State(StartState),
    WaitingOnMilk(WaitingOnMilkState),
    WaitingOnBread(WaitingOnBreadState),
    End(EndState),
}
        \end{lstlisting}
	\end{minipage}
    \caption{Breakfirst的状态机描述和与之对应的可能状态}
\end{figure}

\begin{lstlisting}[caption=Breakfirst的状态转换]
impl Future for BreakfirstStateMachine {
    type Output = String;
    fn poll(self: Pin<&mut Self>, fo: &mut Food) -> Poll<Self::Output> {
        loop {
            match self {
                BreakfirstStateMachine::Start(state) => {}
                BreakfirstStateMachine::WaitingOnMilk(state) => {}
                BreakfirstStateMachine::WaitingOnBread(state) => {}
                BreakfirstStateMachine::End(state) => {}
            }
        }
    }
}
\end{lstlisting}



